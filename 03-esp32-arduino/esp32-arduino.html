<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ESP32 with Arduino &amp; PlatformIO - OpenLCB Programmer&#x27;s Guide</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title-page.html">OpenLCB Programmer's Guide</a></li><li class="chapter-item expanded "><a href="../01-intro/intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01-intro/node_architecture.html"><strong aria-hidden="true">1.1.</strong> Node</a></li><li class="chapter-item expanded "><a href="../01-intro/intro_can.html"><strong aria-hidden="true">1.2.</strong> CAN</a></li><li class="chapter-item expanded "><a href="../01-intro/intro_async_blink.html"><strong aria-hidden="true">1.3.</strong> Node Startup Sequence</a></li><li class="chapter-item expanded "><a href="../01-intro/intro_ab_events.html"><strong aria-hidden="true">1.4.</strong> Events and Run Mode</a></li></ol></li><li class="chapter-item expanded "><a href="../02-start/start.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../02-start/arduino-and-migration.html"><strong aria-hidden="true">2.1.</strong> Arduino for Early Chapters (Migration Path)</a></li><li class="chapter-item expanded "><a href="../02-start/openmrn-architecture.html"><strong aria-hidden="true">2.2.</strong> OpenMRN-Lite Architecture &amp; Capabilities</a></li><li class="chapter-item expanded "><a href="../02-start/platform-esp32.html"><strong aria-hidden="true">2.3.</strong> Platform: ESP32 &amp; SPIFFS</a></li><li class="chapter-item expanded "><a href="../02-start/development-environments.html"><strong aria-hidden="true">2.4.</strong> Development Environments &amp; Tooling</a></li><li class="chapter-item expanded "><a href="../02-start/platform-and-transports.html"><strong aria-hidden="true">2.5.</strong> Transports: WiFi &amp; CAN</a></li><li class="chapter-item expanded "><a href="../02-start/monitoring-and-tools.html"><strong aria-hidden="true">2.6.</strong> Monitoring &amp; Verification</a></li></ol></li><li class="chapter-item expanded "><a href="../03-esp32-arduino/esp32-arduino.html" class="active"><strong aria-hidden="true">3.</strong> ESP32 with Arduino &amp; PlatformIO</a></li><li class="chapter-item expanded "><a href="../04-gpio/gpio-hardware.html"><strong aria-hidden="true">4.</strong> Physical I/O with GPIO</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">OpenLCB Programmer&#x27;s Guide</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="esp32-with-arduino--platformio"><a class="header" href="#esp32-with-arduino--platformio">ESP32 with Arduino &amp; PlatformIO</a></h1>
<p>This chapter covers everything needed to build and deploy an OpenLCB node on an ESP32 microcontroller using Arduino and PlatformIO. We'll create a working example that you can modify for your own applications.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The ESP32 is a powerful, affordable microcontroller with built-in WiFi connectivity, making it ideal for learning OpenLCB concepts. In this chapter, we'll build a complete OpenLCB node that simultaneously runs the node protocol stack and hosts a TCP Hub—allowing JMRI to monitor and control your node over WiFi.</p>
<p>As described in the &quot;Network Architecture&quot; section of Chapter 2, your ESP32 will act as both:</p>
<ul>
<li>An <strong>OpenLCB node</strong> that produces and consumes events</li>
<li>A <strong>TCP Hub</strong> listening on port 12021 for JMRI connections</li>
</ul>
<p>We'll be using the <strong>OpenMRN-Lite library</strong>, which is the Arduino version of OpenMRN. If you're curious about why OpenMRN-Lite specifically, or what it can (and can't) do, see Chapter 2.5 (&quot;OpenMRN-Lite Architecture &amp; Capabilities&quot;) for a deeper dive. For now, know that it's the right tool for the job and it has everything we need to build real, functional OpenLCB nodes.</p>
<p>We'll build this in two phases:</p>
<ol>
<li><strong>Software-only</strong>: Create a node that produces and consumes events via JMRI (no physical hardware needed yet)</li>
<li><strong>Hardware integration</strong> (optional): Add a physical button and LED to your breadboard</li>
</ol>
<p>This approach lets you start learning immediately while waiting for breadboard components to arrive.</p>
<h2 id="esp32-board-selection"><a class="header" href="#esp32-board-selection">ESP32 Board Selection</a></h2>
<p>Before installing software, you'll want to order an ESP32 development board. This section helps you choose the right board for this tutorial.</p>
<p>The ESP32 family includes many board variants. For this tutorial, we recommend boards with sufficient GPIO pins, USB programming support, and built-in CAN capability for future chapters.</p>
<h3 id="recommended-board-esp32-devkit-v1"><a class="header" href="#recommended-board-esp32-devkit-v1">Recommended Board: ESP32 DevKit V1</a></h3>
<p><strong>ESP32 DevKit V1 / ESP32-WROOM-32</strong> (Xtensa architecture)</p>
<ul>
<li>Most common and affordable ESP32 development board</li>
<li>30+ GPIO pins available (plenty for expansion)</li>
<li>Built-in USB-to-serial converter (CP2102 or CH340)</li>
<li>4MB flash memory (sufficient for OpenMRNLite applications)</li>
<li>Built-in CAN controller (TWAI) for future CAN chapters</li>
<li><strong>Best OpenMRNLite compatibility</strong> - fully tested and supported</li>
<li>Available from multiple manufacturers (Espressif, DOIT, etc.)</li>
<li>Cost: $5-10 USD</li>
</ul>
<p>This is the board we'll use throughout the tutorial.</p>
<h3 id="alternative-boards"><a class="header" href="#alternative-boards">Alternative Boards</a></h3>
<p><strong>ESP32-DevKitC</strong></p>
<ul>
<li>Official Espressif development board</li>
<li>Similar pinout to DevKit V1</li>
<li>Excellent documentation and support</li>
<li>Slightly more expensive but guaranteed quality</li>
</ul>
<p><strong>ESP32-S3</strong> (Xtensa architecture)</p>
<ul>
<li>Newer variant with USB-OTG support</li>
<li>More memory and GPIO options</li>
<li>Built-in CAN controller</li>
<li>Good OpenMRNLite support</li>
</ul>
<h3 id="boards-to-avoid-for-now"><a class="header" href="#boards-to-avoid-for-now">Boards to Avoid (for now)</a></h3>
<p><strong>ESP32-C3</strong> (RISC-V architecture)</p>
<ul>
<li>Different CPU architecture (RISC-V vs Xtensa)</li>
<li>OpenMRNLite has compatibility issues with ESP32-C3</li>
<li>Missing required ESP-IDF headers in Arduino framework</li>
<li>Wait for future OpenMRNLite updates before using</li>
</ul>
<h3 id="what-you-need-now"><a class="header" href="#what-you-need-now">What You Need Now</a></h3>
<p>To get started with the software-only version:</p>
<ul>
<li><strong>Just the ESP32 board</strong> with USB cable</li>
</ul>
<p>For the hardware integration phase (optional, later):</p>
<ul>
<li>Solderless breadboard</li>
<li>Tactile pushbutton</li>
<li>LED (any color)</li>
<li>220Ω resistor</li>
<li>Jumper wires</li>
</ul>
<h3 id="purchasing"><a class="header" href="#purchasing">Purchasing</a></h3>
<p>ESP32 boards are available from:</p>
<ul>
<li><strong>Amazon</strong> / <strong>eBay</strong>: Search &quot;ESP32 DevKit&quot; (verify reviews)</li>
<li><strong>AliExpress</strong> / <strong>Banggood</strong>: Direct from manufacturers (longer shipping)</li>
<li><strong>Adafruit</strong> / <strong>SparkFun</strong>: Higher quality, better support, higher cost</li>
<li><strong>DigiKey</strong> / <strong>Mouser</strong>: For bulk or commercial projects</li>
</ul>
<p><strong>Order your board now</strong>, then continue with the software setup while you wait for delivery.</p>
<h2 id="platformio-installation--setup"><a class="header" href="#platformio-installation--setup">PlatformIO Installation &amp; Setup</a></h2>
<p>PlatformIO is a professional embedded development platform that provides a unified build system, library management, and debugging tools. It integrates with VS Code to create a powerful development environment.</p>
<h3 id="installing-vs-code"><a class="header" href="#installing-vs-code">Installing VS Code</a></h3>
<p>If you don't already have Visual Studio Code installed:</p>
<ol>
<li>Download VS Code from <a href="https://code.visualstudio.com/">code.visualstudio.com</a></li>
<li>Run the installer for your operating system (Windows, macOS, or Linux)</li>
<li>Follow the installation wizard with default options</li>
<li>Launch VS Code after installation completes</li>
</ol>
<h3 id="installing-platformio-extension"><a class="header" href="#installing-platformio-extension">Installing PlatformIO Extension</a></h3>
<ol>
<li>Open VS Code</li>
<li>Click the Extensions icon in the left sidebar (or press <code>Ctrl+Shift+X</code> / <code>Cmd+Shift+X</code>)</li>
<li>Search for &quot;PlatformIO IDE&quot;</li>
<li>Click <strong>Install</strong> on the &quot;PlatformIO IDE&quot; extension by PlatformIO</li>
<li>Wait for the installation to complete (this may take several minutes as it downloads toolchains)</li>
<li>Restart VS Code when prompted</li>
</ol>
<p>After restarting, you should see a new PlatformIO icon (alien head) in the left sidebar.</p>
<blockquote>
<p><strong>Note</strong>: The ESP32 platform and toolchain will be installed automatically when you create your first project. PlatformIO handles all the toolchain downloads and configuration for you.</p>
</blockquote>
<h2 id="creating-your-first-project-async_blink_esp32"><a class="header" href="#creating-your-first-project-async_blink_esp32">Creating Your First Project: async_blink_esp32</a></h2>
<p>Now we'll create the actual project we'll be working with throughout this chapter. Instead of creating a throwaway test project, we'll jump straight into building our OpenLCB node.</p>
<h3 id="create-the-project"><a class="header" href="#create-the-project">Create the Project</a></h3>
<ol>
<li>Click the PlatformIO icon in the left sidebar</li>
<li>Select <strong>New Project</strong> from Quick Access</li>
<li>Enter project name: <strong>async_blink_esp32</strong></li>
<li>For Board, search and select <strong>DOIT ESP32 DEVKIT V1</strong> (or <code>esp32doit-devkit-v1</code>)</li>
<li>Framework should automatically select <strong>Arduino</strong></li>
<li>Click <strong>Finish</strong></li>
</ol>
<p>PlatformIO will:</p>
<ul>
<li>Create the project structure</li>
<li>Download the ESP32 platform and toolchain (first time only, may take several minutes)</li>
<li>Set up the Arduino framework</li>
<li>Create a basic <code>src/main.cpp</code> file</li>
</ul>
<h3 id="understanding-the-project-structure"><a class="header" href="#understanding-the-project-structure">Understanding the Project Structure</a></h3>
<p>After creation, you'll see this structure:</p>
<pre><code>async_blink_esp32/
├── platformio.ini     # Project configuration
├── src/
│   └── main.cpp       # Your application code (we'll replace this)
├── lib/               # Project-specific libraries
├── include/           # Header files
└── test/              # Unit tests (optional)
</code></pre>
<p>The <code>platformio.ini</code> file should look like this:</p>
<pre><code class="language-ini">[env:esp32doit-devkit-v1]
platform = espressif32
board = esp32doit-devkit-v1
framework = arduino
monitor_speed = 115200
</code></pre>
<p><strong>Note</strong>: The <code>monitor_speed = 115200</code> setting configures the serial monitor baud rate to match what our code will use. Without this, the serial output will appear as garbled characters.</p>
<h2 id="adding-openmrnlite-to-your-project"><a class="header" href="#adding-openmrnlite-to-your-project">Adding OpenMRNLite to Your Project</a></h2>
<p>OpenMRNLite is the lightweight version of OpenMRN designed for Arduino-compatible platforms. It provides all the core LCC/OpenLCB functionality without the full complexity of the OpenMRN framework.</p>
<h3 id="installation-via-platformioini"><a class="header" href="#installation-via-platformioini">Installation via platformio.ini</a></h3>
<p>Open the <code>platformio.ini</code> file in your <code>async_blink_esp32</code> project and add OpenMRNLite to the library dependencies:</p>
<pre><code class="language-ini">[env:esp32doit-devkit-v1]
platform = espressif32
board = esp32doit-devkit-v1
framework = arduino
lib_deps = openmrn/OpenMRNLite@2.0.0
monitor_speed = 115200
</code></pre>
<p>Save the file. That's it! PlatformIO will automatically download OpenMRNLite from the registry when you build the project.</p>
<p><strong>About monitor_speed</strong>: This setting ensures the serial monitor uses 115200 baud, matching the <code>Serial.begin(115200)</code> call in our code. Without this, you'll see garbled output instead of readable text.</p>
<p><strong>Why version 2.0.0?</strong></p>
<ul>
<li>Version 2.0.0 is fully compatible with PlatformIO's current ESP32 platform</li>
<li>Later versions (2.2.x+) require newer ESP-IDF features not yet available in PlatformIO</li>
<li>All core OpenLCB functionality is present in v2.0.0</li>
</ul>
<blockquote>
<p><strong>About PlatformIO and Arduino-ESP32 versions</strong></p>
<p>You may notice that PlatformIO uses Arduino-ESP32 v2.0.17 while the Arduino IDE can install v3.x. This isn't a bug — it's intentional:</p>
<ul>
<li><strong>PlatformIO prioritizes stability</strong> over bleeding-edge features. They thoroughly test each framework version across hundreds of boards, toolchains, and debuggers before releasing.</li>
<li><strong>Arduino-ESP32 3.x introduced major breaking changes</strong> in the build system, partition handling, WiFi stack, and more. PlatformIO waits for these to stabilize before adoption.</li>
<li><strong>Small team, massive ecosystem</strong>: PlatformIO maintains ESP32, STM32, RP2040, AVR, and many other platforms with a much smaller team than Espressif has for Arduino-ESP32 alone.</li>
</ul>
<p>This is why we use OpenMRNLite v2.0.0 — it's designed for the stable Arduino-ESP32 2.x that PlatformIO provides. You're trading cutting-edge features for rock-solid reliability, which is perfect for learning OpenLCB fundamentals.</p>
</blockquote>
<h3 id="verification"><a class="header" href="#verification">Verification</a></h3>
<p>Let's verify everything is working by building the project:</p>
<ol>
<li>
<p>In VS Code, click the PlatformIO icon in the left sidebar</p>
</li>
<li>
<p>Under <strong>PROJECT TASKS</strong> → <strong>esp32doit-devkit-v1</strong>, click <strong>Build</strong></p>
</li>
<li>
<p>PlatformIO will:</p>
<ul>
<li>Download OpenMRNLite (first time only)</li>
<li>Compile the default <code>main.cpp</code></li>
<li>Display build output</li>
</ul>
</li>
<li>
<p>Look for <strong>SUCCESS</strong> at the end of the output</p>
</li>
</ol>
<blockquote>
<p><strong>Note</strong>: The first build will take longer as PlatformIO downloads the library and compiles it. Subsequent builds are much faster.</p>
</blockquote>
<p>If the build succeeds, OpenMRNLite is installed correctly and you're ready to write code!</p>
<h2 id="writing-the-async_blink_esp32-code"><a class="header" href="#writing-the-async_blink_esp32-code">Writing the async_blink_esp32 Code</a></h2>
<p>Now we'll create the actual OpenLCB node that produces alternating events. This demonstrates the core OpenLCB protocol behavior you learned in Chapter 1 (node initialization and event production) without requiring physical hardware.</p>
<h3 id="creating-the-configuration-header"><a class="header" href="#creating-the-configuration-header">Creating the Configuration Header</a></h3>
<p>OpenMRNLite requires a configuration structure (CDI - Configuration Description Information) even for simple nodes. We'll create a minimal config.h file.</p>
<p>Create the file <code>include/config.h</code> with this content:</p>
<pre><code class="language-cpp">#ifndef _ASYNC_BLINK_CONFIG_H_
#define _ASYNC_BLINK_CONFIG_H_

#include &quot;openlcb/ConfigRepresentation.hxx&quot;
#include &quot;openlcb/MemoryConfig.hxx&quot;

namespace openlcb {

/// SNIP Static Data - Manufacturer information (read-only, compiled into firmware)
extern const SimpleNodeStaticValues SNIP_STATIC_DATA = {
    4,               // Version
    &quot;OpenMRN&quot;,       // Manufacturer
    &quot;async_blink&quot;,   // Model
    &quot;ESP32&quot;,         // Hardware version
    &quot;1.00&quot;           // Software version
};

/// SNIP Dynamic Data - User-editable node name and description
/// These are stored in the config file and can be read/written via JMRI
static const char SNIP_NODE_NAME[] = &quot;async_blink&quot;;
static const char SNIP_NODE_DESC[] = &quot;ESP32 Blink demo&quot;;

/// Version number for the configuration structure
static constexpr uint16_t CANONICAL_VERSION = 0x0001;

/// Minimal configuration segment with just internal config
CDI_GROUP(AsyncBlinkSegment, Segment(MemoryConfigDefs::SPACE_CONFIG), Offset(128));
CDI_GROUP_ENTRY(internal_config, InternalConfigData);
CDI_GROUP_END();

/// The main CDI structure
CDI_GROUP(ConfigDef, MainCdi());
CDI_GROUP_ENTRY(ident, Identification);
CDI_GROUP_ENTRY(acdi, Acdi);
CDI_GROUP_ENTRY(userinfo, UserInfoSegment, Name(&quot;User Info&quot;));
CDI_GROUP_ENTRY(seg, AsyncBlinkSegment, Name(&quot;Settings&quot;));
CDI_GROUP_END();

} // namespace openlcb

#endif // _ASYNC_BLINK_CONFIG_H_
</code></pre>
<p><strong>What this does</strong>: Defines the CDI (Configuration Description Information) structure that OpenMRNLite uses to expose node configuration to JMRI. The configuration includes:</p>
<ul>
<li><strong>SNIP Static Data</strong>: Read-only manufacturer, model, and version information (compiled into firmware)</li>
<li><strong>SNIP Dynamic Data</strong>: User-editable node name and description stored in the config file (visible in JMRI node properties)</li>
<li><strong>Acdi and UserInfo</strong>: Standard OpenLCB configuration segments</li>
<li><strong>AsyncBlinkSegment</strong>: Internal configuration area for this node (currently minimal, but available for future expansion)</li>
</ul>
<blockquote>
<p><strong>Configuration Storage</strong>: Configuration is saved to SPIFFS on first boot (via <code>factory_reset()</code>) and persists across restarts. In v0.1, the initial configuration is hardcoded in the constants above. In Chapter 5, we'll make configuration editable through JMRI and learn how to handle updates via <code>apply_configuration()</code>. See &quot;Configuration &amp; JMRI&quot; section below for more details.</p>
</blockquote>
<h3 id="the-complete-main-code"><a class="header" href="#the-complete-main-code">The Complete Main Code</a></h3>
<p>Now replace the contents of <code>src/main.cpp</code> with the following code:</p>
<pre><code class="language-cpp">/** \copyright
 * Copyright (c) 2024, OpenLCB Technical Introduction
 * All rights reserved.
 *
 * Example code for educational purposes demonstrating OpenLCB node startup
 * and event handling on ESP32 using WiFi/TCP transport.
 *
 * \file main.cpp
 *
 * Simple async_blink example for ESP32 with WiFi - produces two alternating
 * events every second, demonstrating OpenLCB node initialization and event
 * production without requiring physical GPIO hardware.
 */

#include &lt;Arduino.h&gt;
#include &lt;WiFi.h&gt;
#include &lt;SPIFFS.h&gt;
#include &lt;OpenMRNLite.h&gt;
#include &quot;utils/GcTcpHub.hxx&quot;

#include &quot;config.h&quot;

// WiFi credentials - CHANGE THESE to match your network
const char* ssid = &quot;YourWiFiSSID&quot;;
const char* password = &quot;YourWiFiPassword&quot;;

// OpenLCB Node ID - must be unique on your network
// This ID is in the reserved range for experimental use
static constexpr uint64_t NODE_ID = 0x050201020200ULL;

// Event IDs that will be alternated
// These match the desktop async_blink example
static const uint64_t EVENT_ID_0 = 0x0502010202000000ULL;
static const uint64_t EVENT_ID_1 = 0x0502010202000001ULL;

// Create the OpenMRN stack object
OpenMRN openmrn(NODE_ID);

// TCP Hub for JMRI connectivity
GcTcpHub* tcp_hub = nullptr;

// ConfigDef comes from config.h and defines the configuration layout
static constexpr openlcb::ConfigDef cfg(0);

// OpenLCB configuration - required by OpenMRNLite
namespace openlcb {
  // Name of CDI.xml to generate dynamically
  const char CDI_FILENAME[] = &quot;/spiffs/cdi.xml&quot;;
  
  // This will stop openlcb from exporting the CDI memory space upon start
  const char CDI_DATA[] = &quot;&quot;;
  
  // Path to the config file and its size
  const char* const CONFIG_FILENAME = &quot;/spiffs/openlcb_config&quot;;
  const size_t CONFIG_FILE_SIZE = cfg.seg().size() + cfg.seg().offset();
  
  // SNIP (Simple Node Information Protocol) dynamic data storage
  const char* const SNIP_DYNAMIC_FILENAME = CONFIG_FILENAME;
}

// State variable to track which event to send
bool event_state = false;

// Timing for event production (1 second = 1000 milliseconds)
unsigned long last_event_time = 0;
const unsigned long EVENT_INTERVAL = 1000;

/**
 * Configuration update listener for factory reset and config persistence.
 * 
 * factory_reset() is called automatically by OpenMRN on first boot (when the
 * config file doesn't exist yet). It initializes SNIP dynamic data (node name
 * and description) which is then saved to SPIFFS and persists across restarts.
 * 
 * apply_configuration() is called when the user modifies configuration through
 * JMRI (or other LCC tools). In v0.1, it returns UPDATED without doing anything.
 * In Chapter 5, we'll implement actual config persistence when this is called.
 */
class FactoryResetHelper : public DefaultConfigUpdateListener
{
public:
    UpdateAction apply_configuration(int fd, bool initial_load,
                                     BarrierNotifiable *done) OVERRIDE
    {
        AutoNotify n(done);
        // In v0.1, we don't handle runtime config changes yet.
        // Real nodes would persist changes here when the user modifies
        // configuration through JMRI. See Chapter 5 for implementation.
        return UPDATED;
    }

    void factory_reset(int fd) override
    {
        // Called on first boot to initialize the configuration file.
        // Write initial SNIP dynamic data (node name and description).
        // This data is then saved to SPIFFS and is displayed by JMRI
        // in the node properties dialog.
        cfg.userinfo().name().write(fd, openlcb::SNIP_NODE_NAME);
        cfg.userinfo().description().write(fd, openlcb::SNIP_NODE_DESC);
    }
} factory_reset_helper;

/**
 * Initialize Serial communication and print startup banner.
 */
void init_serial() {
  Serial.begin(115200);
  delay(500);  // Give serial time to initialize
  
  Serial.println(&quot;\n\n=== OpenLCB async_blink ESP32 Example ===&quot;);
  Serial.printf(&quot;Node ID: 0x%012llX\n&quot;, NODE_ID);
  Serial.printf(&quot;Event 0: 0x%016llX\n&quot;, EVENT_ID_0);
  Serial.printf(&quot;Event 1: 0x%016llX\n&quot;, EVENT_ID_1);
}

/**
 * Initialize SPIFFS filesystem for configuration storage.
 */
void init_filesystem() {
  Serial.println(&quot;\nInitializing SPIFFS...&quot;);
  if (!SPIFFS.begin(true)) {  // true = format if mount fails
    Serial.println(&quot;SPIFFS mount failed! Halting.&quot;);
    while (1) { delay(1000); }  // Stop here if filesystem fails
  }
  Serial.println(&quot;SPIFFS initialized successfully&quot;);
}

/**
 * Connect to WiFi network.
 */
void init_network() {
  Serial.printf(&quot;\nConnecting to WiFi SSID: %s\n&quot;, ssid);
  WiFi.begin(ssid, password);
  
  // Wait for WiFi connection
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(&quot;.&quot;);
  }
  
  Serial.println(&quot;\nWiFi connected!&quot;);
  Serial.printf(&quot;IP Address: %s\n&quot;, WiFi.localIP().toString().c_str());
}

/**
 * Initialize OpenMRN stack and configuration.
 * This creates the config file and starts the stack.
 * FactoryResetHelper automatically initializes SNIP data on first boot.
 */
void init_openlcb_stack() {
  // Create the CDI.xml dynamically
  // CDI describes what configuration options are available
  Serial.println(&quot;\nCreating CDI configuration descriptor...&quot;);
  openmrn.create_config_descriptor_xml(cfg, openlcb::CDI_FILENAME);
  
  // Create the config file if it doesn't exist
  // OpenMRNLite requires this even for simple nodes
  Serial.println(&quot;Initializing OpenLCB configuration...&quot;);
  openmrn.stack()-&gt;create_config_file_if_needed(cfg.seg().internal_config(),
                                                  openlcb::CANONICAL_VERSION,
                                                  openlcb::CONFIG_FILE_SIZE);

  // Start the OpenMRN stack
  // This initiates the OpenLCB node initialization sequence:
  // 1. Check ID (CID) - verifies Node ID is unique
  // 2. Reserve ID (RID) - claims the Node ID
  // 3. Announce Membership (AMD) - announces node to network
  // 4. Initialization Complete - node enters normal operation
  Serial.println(&quot;\nStarting OpenLCB stack...&quot;);
  openmrn.begin();
  
  // Start the executor thread for background processing
  // REQUIRED for TCP Hub to accept connections
  Serial.println(&quot;Starting executor thread...&quot;);
  openmrn.start_executor_thread();
}

/**
 * Initialize TCP Hub for JMRI connectivity.
 */
void init_tcp_hub() {
  Serial.println(&quot;Starting TCP Hub on port 12021...&quot;);
  tcp_hub = new GcTcpHub(
    openmrn.stack()-&gt;can_hub(),  // Reference to the CAN hub
    12021                        // TCP port (standard for OpenLCB)
  );
  Serial.println(&quot;TCP Hub listening. JMRI can connect to this device on port 12021&quot;);
}

/**
 * Arduino setup() - runs once at startup
 * 
 * This function initializes all hardware and software subsystems:
 * 1. Serial communication
 * 2. SPIFFS filesystem
 * 3. WiFi network
 * 4. OpenMRN stack
 * 5. TCP Hub for JMRI connectivity
 */
void setup() {
  init_serial();
  init_filesystem();
  init_network();
  init_openlcb_stack();
  init_tcp_hub();
  
  Serial.println(&quot;OpenLCB node initialization complete!&quot;);
  Serial.println(&quot;Entering run mode - will alternate events every 1 second\n&quot;);
  
  // Record start time for event production
  last_event_time = millis();
}

/**
 * Arduino loop() - runs continuously
 * 
 * This function:
 * 1. Calls openmrn.loop() to process OpenLCB protocol messages
 * 2. Alternates between two events every second
 * 3. Prints event production to serial monitor
 */
void loop() {
  // CRITICAL: Must call openmrn.loop() frequently to process messages
  openmrn.loop();
  
  // Check if it's time to produce an event (every 1 second)
  unsigned long current_time = millis();
  if (current_time - last_event_time &gt;= EVENT_INTERVAL) {
    // Alternate event state
    event_state = !event_state;
    
    // Send the event
    uint64_t event_to_send = event_state ? EVENT_ID_1 : EVENT_ID_0;
    openmrn.stack()-&gt;executor()-&gt;add(new CallbackExecutable([event_to_send]() {
      openmrn.stack()-&gt;send_event(event_to_send);
    }));
    
    // Print to serial monitor
    Serial.printf(&quot;Produced event: 0x%016llX (state: %d)\n&quot;, 
                  event_to_send, event_state ? 1 : 0);
    
    // Update timing
    last_event_time = current_time;
  }
}
</code></pre>
<h3 id="code-walkthrough"><a class="header" href="#code-walkthrough">Code Walkthrough</a></h3>
<p>This code is organized into:</p>
<ol>
<li><strong>Configuration</strong> (config.h): Node identity and CDI structure</li>
<li><strong>Initialization</strong> (setup function with helpers): WiFi, SPIFFS, OpenLCB stack, TCP Hub</li>
<li><strong>Event production</strong> (loop function): Alternate between two events every second</li>
</ol>
<p>The code includes detailed comments explaining each section. We'll walk through the key concepts below.</p>
<h4 id="1-includes-and-wifi-configuration"><a class="header" href="#1-includes-and-wifi-configuration">1. Includes and WiFi Configuration</a></h4>
<pre><code class="language-cpp">#include &lt;Arduino.h&gt;
#include &lt;WiFi.h&gt;
#include &lt;SPIFFS.h&gt;
#include &lt;OpenMRNLite.h&gt;

#include &quot;config.h&quot;

const char* ssid = &quot;YourWiFiSSID&quot;;
const char* password = &quot;YourWiFiPassword&quot;;
</code></pre>
<p><strong>Required includes</strong>:</p>
<ul>
<li><code>Arduino.h</code>: Core Arduino framework</li>
<li><code>WiFi.h</code>: ESP32 WiFi library for network connectivity</li>
<li><code>SPIFFS.h</code>: ESP32 filesystem library for configuration storage</li>
<li><code>OpenMRNLite.h</code>: OpenLCB protocol stack</li>
<li><code>config.h</code>: Our configuration header with CDI definitions</li>
</ul>
<p><strong>Action Required</strong>: Replace <code>ssid</code> and <code>password</code> with your actual WiFi network credentials.</p>
<ul>
<li>ESP32 only supports <strong>2.4GHz WiFi networks</strong> (not 5GHz)</li>
<li>SSID is case-sensitive</li>
<li>This is hardcoded for simplicity - production code would use configuration storage</li>
</ul>
<h4 id="2-node-and-event-ids"><a class="header" href="#2-node-and-event-ids">2. Node and Event IDs</a></h4>
<pre><code class="language-cpp">static constexpr uint64_t NODE_ID = 0x050201020200ULL;
static const uint64_t EVENT_ID_0 = 0x0502010202000000ULL;
static const uint64_t EVENT_ID_1 = 0x0502010202000001ULL;
</code></pre>
<p><strong>Node ID</strong>: Every OpenLCB node must have a globally unique 48-bit identifier. This ID (<code>0x050201020200</code>) is in the experimental range - safe for learning but not for production deployment.</p>
<p><strong>Event IDs</strong>: These 64-bit identifiers represent the two events our node will produce. Notice they differ only in the last byte (<code>00</code> vs <code>01</code>), making them easy to track. These match the desktop <code>async_blink</code> OpenMRN example for consistency.</p>
<h4 id="3-configuration-and-openmrn-stack"><a class="header" href="#3-configuration-and-openmrn-stack">3. Configuration and OpenMRN Stack</a></h4>
<pre><code class="language-cpp">OpenMRN openmrn(NODE_ID);
static constexpr openlcb::ConfigDef cfg(0);

namespace openlcb {
  const char CDI_FILENAME[] = &quot;/spiffs/cdi.xml&quot;;
  const char CDI_DATA[] = &quot;&quot;;
  const char* const CONFIG_FILENAME = &quot;/spiffs/openlcb_config&quot;;
  const size_t CONFIG_FILE_SIZE = cfg.seg().size() + cfg.seg().offset();
  const char* const SNIP_DYNAMIC_FILENAME = CONFIG_FILENAME;
}
</code></pre>
<p><strong>OpenMRN stack</strong>: Creates the entire OpenLCB protocol stack (message routing, node initialization, event handling, network transport).</p>
<p><strong>ConfigDef</strong>: Instantiates the CDI configuration structure from config.h (already described above). The <code>(0)</code> parameter is the offset in memory.</p>
<p><strong>OpenLCB namespace constants</strong>:</p>
<ul>
<li><code>CDI_FILENAME</code>: Path where the dynamic CDI.xml file will be written (used by JMRI for configuration discovery)</li>
<li><code>CDI_DATA</code>: Empty string tells OpenMRN to generate CDI dynamically instead of using a static resource</li>
<li><code>CONFIG_FILENAME</code>: Path to the config file in SPIFFS filesystem (note <code>/spiffs/</code> prefix)</li>
<li><code>CONFIG_FILE_SIZE</code>: Calculated as the size of all configuration segments. This ensures the file is large enough for all data (SNIP + internal config + UserInfo)</li>
<li><code>SNIP_DYNAMIC_FILENAME</code>: Store SNIP data in the same file as config</li>
</ul>
<h4 id="4-factoryresethelper-and-configuration-initialization"><a class="header" href="#4-factoryresethelper-and-configuration-initialization">4. FactoryResetHelper and Configuration Initialization</a></h4>
<pre><code class="language-cpp">class FactoryResetHelper : public DefaultConfigUpdateListener
{
public:
    UpdateAction apply_configuration(int fd, bool initial_load,
                                     BarrierNotifiable *done) OVERRIDE
    {
        AutoNotify n(done);
        return UPDATED;
    }

    void factory_reset(int fd) override
    {
        cfg.userinfo().name().write(fd, openlcb::SNIP_NODE_NAME);
        cfg.userinfo().description().write(fd, openlcb::SNIP_NODE_DESC);
    }
} factory_reset_helper;
</code></pre>
<p>This class handles configuration lifecycle events:</p>
<p><strong><code>factory_reset(int fd)</code></strong>: Called by OpenMRN automatically on first boot when the config file is created. It initializes the SNIP dynamic data using OpenMRN's built-in CDI framework:</p>
<ul>
<li><code>cfg.userinfo().name().write()</code>: Writes the node name to the correct offset in the config file</li>
<li><code>cfg.userinfo().description().write()</code>: Writes the node description to the correct offset</li>
</ul>
<p>This approach is better than manual file I/O because:</p>
<ul>
<li>OpenMRN handles all byte offsets and layout automatically</li>
<li>Uses the same CDI structure (ConfigDef from config.h) consistently</li>
<li>Less prone to errors (no manual <code>fseek</code>, <code>fwrite</code> calls)</li>
<li>Foundation ready for <code>apply_configuration()</code> in future chapters when users modify config via JMRI</li>
</ul>
<blockquote>
<p><strong><code>apply_configuration()</code></strong>: Currently returns UPDATED without doing anything. In a real node, this would handle persistence when users modify configuration through JMRI. For v0.1, config is read-only.</p>
</blockquote>
<p><strong>SNIP data</strong>: The node name and description are displayed by JMRI in the node properties dialog, helping identify which ESP32 is which on your network.</p>
<h4 id="5-wifi-connection"><a class="header" href="#5-wifi-connection">5. WiFi Connection</a></h4>
<pre><code class="language-cpp">void init_network() {
  Serial.printf(&quot;\nConnecting to WiFi SSID: %s\n&quot;, ssid);
  WiFi.begin(ssid, password);
  
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(&quot;.&quot;);
  }
  
  Serial.println(&quot;\nWiFi connected!&quot;);
  Serial.printf(&quot;IP Address: %s\n&quot;, WiFi.localIP().toString().c_str());
}
</code></pre>
<p>This helper function establishes the WiFi connection before starting OpenLCB. The ESP32 won't be able to communicate on the OpenLCB network until WiFi is connected, so we wait here.</p>
<p>The dots printed to serial provide visual feedback during connection.</p>
<h4 id="6-initialization-helper-functions-and-setup"><a class="header" href="#6-initialization-helper-functions-and-setup">6. Initialization Helper Functions and Setup</a></h4>
<pre><code class="language-cpp">void init_openlcb_stack() {
  Serial.println(&quot;\nCreating CDI configuration descriptor...&quot;);
  openmrn.create_config_descriptor_xml(cfg, openlcb::CDI_FILENAME);
  
  Serial.println(&quot;Initializing OpenLCB configuration...&quot;);
  openmrn.stack()-&gt;create_config_file_if_needed(cfg.seg().internal_config(),
                                                  openlcb::CANONICAL_VERSION,
                                                  openlcb::CONFIG_FILE_SIZE);

  Serial.println(&quot;\nStarting OpenLCB stack...&quot;);
  openmrn.begin();
  
  Serial.println(&quot;Starting executor thread...&quot;);
  openmrn.start_executor_thread();
}
</code></pre>
<p>This helper function performs several critical initialization steps:</p>
<ol>
<li>
<p><strong>Create CDI.xml dynamically</strong>: <code>openmrn.create_config_descriptor_xml()</code> generates a CDI (Configuration Description Information) file that describes all available configuration options. JMRI uses this file to know what settings the node supports. The file is written to <code>/spiffs/cdi.xml</code>.</p>
</li>
<li>
<p><strong>Create config file if needed</strong>: <code>create_config_file_if_needed()</code> ensures the config file exists with proper structure. On first boot:</p>
<ul>
<li>File is created with space for internal config, SNIP data, and UserInfo</li>
<li>FactoryResetHelper's <code>factory_reset()</code> is called automatically</li>
<li>SNIP user data (name and description) is populated</li>
</ul>
</li>
<li>
<p><strong>Start OpenMRN stack</strong>: <code>openmrn.begin()</code> initiates the entire OpenLCB protocol sequence (CID, RID, AMD) as described in Chapter 1.</p>
</li>
<li>
<p><strong>Start executor thread</strong>: Background thread for processing OpenLCB messages. <strong>This is required for TCP Hub to work.</strong></p>
</li>
</ol>
<h4 id="7-tcp-hub-for-jmri-connectivity"><a class="header" href="#7-tcp-hub-for-jmri-connectivity">7. TCP Hub for JMRI Connectivity</a></h4>
<pre><code class="language-cpp">void init_tcp_hub() {
  Serial.println(&quot;Starting TCP Hub on port 12021...&quot;);
  tcp_hub = new GcTcpHub(
    openmrn.stack()-&gt;can_hub(),
    12021
  );
  Serial.println(&quot;TCP Hub listening. JMRI can connect to this device on port 12021&quot;);
}
</code></pre>
<p>This helper function creates a TCP server on port 12021 using the GridConnect protocol (the ASCII format that JMRI expects). It's passed:</p>
<ul>
<li><code>openmrn.stack()-&gt;can_hub()</code>: Reference to the message router</li>
<li><code>12021</code>: The TCP port to listen on (standard for OpenLCB TCP hubs)</li>
</ul>
<p>The TCP Hub allows JMRI and other TCP clients to connect and monitor your node's events in real-time. Multiple JMRI instances can connect simultaneously; messages are routed between all connected clients and the local node.</p>
<h4 id="8-main-setup-function"><a class="header" href="#8-main-setup-function">8. Main Setup Function</a></h4>
<pre><code class="language-cpp">void setup() {
  init_serial();
  init_filesystem();
  init_network();
  init_openlcb_stack();
  init_tcp_hub();
  
  Serial.println(&quot;OpenLCB node initialization complete!&quot;);
  Serial.println(&quot;Entering run mode - will alternate events every 1 second\n&quot;);
  
  last_event_time = millis();
}
</code></pre>
<p>The <code>setup()</code> function calls four helper functions in sequence:</p>
<ol>
<li><strong><code>init_serial()</code></strong>: Initialize Serial, print startup banner with Node ID and Event IDs</li>
<li><strong><code>init_filesystem()</code></strong>: Initialize SPIFFS filesystem</li>
<li><strong><code>init_network()</code></strong>: Connect to WiFi (required before OpenLCB)</li>
<li><strong><code>init_openlcb_stack()</code></strong>: Create CDI file, config file, initialize SNIP data via FactoryResetHelper, start OpenLCB protocol stack, start executor thread</li>
<li><strong><code>init_tcp_hub()</code></strong>: Start TCP server for JMRI connectivity</li>
</ol>
<p><strong>Why break it down?</strong> Each helper function focuses on a single responsibility, making the code easier to understand and modify. If you need to add new initialization steps or change how the node starts up, it's clear where to make those changes.</p>
<h4 id="9-event-production-loop"><a class="header" href="#9-event-production-loop">9. Event Production Loop</a></h4>
<pre><code class="language-cpp">void loop() {
  openmrn.loop();  // CRITICAL - processes all OpenLCB messages
  
  unsigned long current_time = millis();
  if (current_time - last_event_time &gt;= EVENT_INTERVAL) {
    event_state = !event_state;
    uint64_t event_to_send = event_state ? EVENT_ID_1 : EVENT_ID_0;
    
    openmrn.stack()-&gt;executor()-&gt;add(new CallbackExecutable([event_to_send]() {
      openmrn.stack()-&gt;send_event(event_to_send);
    }));
    
    Serial.printf(&quot;Produced event: 0x%016llX (state: %d)\n&quot;, 
                  event_to_send, event_state ? 1 : 0);
    
    last_event_time = current_time;
  }
}
</code></pre>
<p><strong>Critical Detail</strong>: <code>openmrn.loop()</code> must be called frequently (ideally every few milliseconds). This processes:</p>
<ul>
<li>Incoming network messages</li>
<li>Outgoing message queues</li>
<li>Protocol state machines</li>
<li>Internal timers</li>
</ul>
<p><strong>Event Production</strong>: Every 1000ms (1 second), we:</p>
<ol>
<li>Toggle <code>event_state</code> (false → true → false → ...)</li>
<li>Select which event ID to send based on state</li>
<li>Queue the event for transmission using the executor</li>
<li>Print confirmation to serial monitor</li>
</ol>
<p><strong>Why use the executor?</strong> OpenLCB message handling runs in a separate execution context. The <code>executor()-&gt;add()</code> pattern ensures thread-safe event production.</p>
<p><strong>Critical Detail</strong>: <code>openmrn.loop()</code> must be called frequently (ideally every few milliseconds). This processes:</p>
<ul>
<li>Incoming network messages</li>
<li>Outgoing message queues</li>
<li>Protocol state machines</li>
<li>Internal timers</li>
</ul>
<p><strong>Event Production</strong>: Every 1000ms (1 second), we:</p>
<ol>
<li>Toggle <code>event_state</code> (false → true → false → ...)</li>
<li>Select which event ID to send based on state</li>
<li>Queue the event for transmission using the executor</li>
<li>Print confirmation to serial monitor</li>
</ol>
<p><strong>Why use the executor?</strong> OpenLCB message handling runs in a separate execution context. The <code>executor()-&gt;add()</code> pattern ensures thread-safe event production.</p>
<h3 id="expected-serial-monitor-output"><a class="header" href="#expected-serial-monitor-output">Expected Serial Monitor Output</a></h3>
<p>When the code runs, you should see output like this:</p>
<pre><code>=== OpenLCB async_blink ESP32 Example ===
Node ID: 0x050201020200
Event 0: 0x0502010202000000
Event 1: 0x0502010202000001

Initializing SPIFFS...
SPIFFS initialized successfully

Connecting to WiFi SSID: YourNetwork
.....
WiFi connected!
IP Address: 192.168.1.100

Creating CDI configuration descriptor...
Initializing OpenLCB configuration...

Starting OpenLCB stack...
Starting executor thread...
Starting TCP Hub on port 12021...
TCP Hub listening. JMRI can connect to this device on port 12021

OpenLCB node initialization complete!
Entering run mode - will alternate events every 1 second

Produced event: 0x0502010202000000 (state: 0)
Produced event: 0x0502010202000001 (state: 1)
Produced event: 0x0502010202000000 (state: 0)
Produced event: 0x0502010202000001 (state: 1)
...
</code></pre>
<p><strong>On First Run Only</strong>: You may see a brief pause and an SPIFFS error message:</p>
<pre><code>Initializing SPIFFS...
E (523) SPIFFS: mount failed, -10025
SPIFFS initialized successfully
</code></pre>
<p>This is <strong>normal and expected</strong>. On first boot, SPIFFS needs to format the filesystem, which takes approximately <strong>20 seconds</strong> on ESP32 DevKit. The error message appears because the filesystem doesn't exist yet, but the <code>SPIFFS.begin(true)</code> call automatically formats it. During this time, the ESP32 will appear to hang—just wait and don't interrupt it. Subsequent boots will skip this formatting step and proceed immediately.</p>
<p>This confirms:</p>
<ul>
<li>✅ SPIFFS filesystem initialized (formatted on first run if needed)</li>
<li>✅ WiFi connection succeeded (shows your network SSID and IP address)</li>
<li>✅ OpenLCB node initialized (config file created, SNIP data written)</li>
<li>✅ <strong>TCP Hub is listening on port 12021</strong> - JMRI can now connect!</li>
<li>✅ Events are being produced alternately</li>
</ul>
<h3 id="before-you-build"><a class="header" href="#before-you-build">Before You Build</a></h3>
<p><strong>Update WiFi credentials in the code!</strong> The build will succeed even with placeholder credentials, but the ESP32 won't connect to WiFi when you upload it.</p>
<h2 id="building-and-uploading-to-esp32"><a class="header" href="#building-and-uploading-to-esp32">Building and Uploading to ESP32</a></h2>
<p>Now that you have the complete code, let's build it, upload it to your ESP32, and verify it works through the serial monitor.</p>
<h3 id="building-the-project"><a class="header" href="#building-the-project">Building the Project</a></h3>
<ol>
<li>
<p><strong>Save the modified main.cpp file</strong> (<code>Ctrl+S</code> / <code>Cmd+S</code>)</p>
</li>
<li>
<p><strong>Open the PlatformIO sidebar</strong>:</p>
<ul>
<li>Click the PlatformIO icon (alien head) in VS Code's left sidebar</li>
<li>Or use the bottom toolbar's checkmark icon (Build)</li>
</ul>
</li>
<li>
<p><strong>Build the project</strong>:</p>
<ul>
<li>In PROJECT TASKS → <strong>esp32doit-devkit-v1</strong>, click <strong>Build</strong></li>
<li>Or click the checkmark (✓) icon in the bottom toolbar</li>
<li>Or press <code>Ctrl+Alt+B</code> / <code>Cmd+Alt+B</code></li>
</ul>
</li>
<li>
<p><strong>Watch the build output</strong>:</p>
<pre><code>Building in release mode
Compiling .pio/build/esp32doit-devkit-v1/src/main.cpp.o
Linking .pio/build/esp32doit-devkit-v1/firmware.elf
Building .pio/build/esp32doit-devkit-v1/firmware.bin
========================= [SUCCESS] Took 5.23 seconds =========================
</code></pre>
</li>
</ol>
<p>The first build takes longer because it compiles OpenMRNLite. Subsequent builds are much faster.</p>
<p><strong>If the build fails</strong>, check:</p>
<ul>
<li>WiFi credentials are properly quoted (strings)</li>
<li>All braces <code>{}</code> and parentheses <code>()</code> match</li>
<li><code>#include &lt;OpenMRNLite.h&gt;</code> is present</li>
<li><code>lib_deps</code> in <code>platformio.ini</code> includes OpenMRNLite</li>
</ul>
<h3 id="connecting-your-esp32"><a class="header" href="#connecting-your-esp32">Connecting Your ESP32</a></h3>
<ol>
<li>
<p><strong>Connect the ESP32 to your computer</strong> via USB cable</p>
<ul>
<li>Use a <strong>data cable</strong>, not a charge-only cable</li>
<li>The ESP32 should power on (onboard LED may light up)</li>
</ul>
</li>
<li>
<p><strong>Identify the COM port</strong> (Windows) or device path (Mac/Linux):</p>
<ul>
<li>PlatformIO usually auto-detects the port</li>
<li>Windows: <code>COM3</code>, <code>COM4</code>, etc.</li>
<li>Mac: <code>/dev/cu.usbserial-*</code> or <code>/dev/cu.wchusbserial*</code></li>
<li>Linux: <code>/dev/ttyUSB0</code> or <code>/dev/ttyACM0</code></li>
</ul>
</li>
<li>
<p><strong>If the port isn't detected</strong>, you may need to install a USB driver:</p>
<ul>
<li><strong>CP2102</strong>: Download from <a href="https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers">Silicon Labs</a></li>
<li><strong>CH340</strong>: Download from <a href="http://www.wch-ic.com/downloads/CH341SER_EXE.html">WCH</a></li>
<li>Most modern operating systems include these drivers</li>
</ul>
</li>
</ol>
<h3 id="uploading-the-firmware"><a class="header" href="#uploading-the-firmware">Uploading the Firmware</a></h3>
<ol>
<li>
<p><strong>Upload the firmware</strong>:</p>
<ul>
<li>In PROJECT TASKS → <strong>esp32doit-devkit-v1</strong>, click <strong>Upload</strong></li>
<li>Or click the arrow (→) icon in the bottom toolbar</li>
<li>Or press <code>Ctrl+Alt+U</code> / <code>Cmd+Alt+U</code></li>
</ul>
</li>
<li>
<p><strong>Watch the upload process</strong>:</p>
<pre><code>Configuring upload protocol...
Looking for upload port...
Auto-detected: COM3
Uploading .pio/build/esp32doit-devkit-v1/firmware.bin
esptool.py v4.5.1
Connecting........__
Chip is ESP32-D0WDQ6 (revision 1)
Writing at 0x00010000... (100 %)
Wrote 876544 bytes (543210 compressed) at 0x00010000 in 48.2 seconds
Leaving...
Hard resetting via RTS pin...
========================= [SUCCESS] Took 52.91 seconds =========================
</code></pre>
</li>
<li>
<p><strong>The ESP32 will automatically reboot</strong> and start running your code</p>
</li>
</ol>
<p><strong>If upload fails</strong>:</p>
<ul>
<li><strong>&quot;Serial port not found&quot;</strong>: Check USB cable connection, try different USB port</li>
<li><strong>&quot;Failed to connect&quot;</strong>: Hold the BOOT button while clicking upload, release after &quot;Connecting...&quot; appears</li>
<li><strong>Permission denied (Linux)</strong>: Add your user to the <code>dialout</code> group: <code>sudo usermod -a -G dialout $USER</code>, then log out and back in</li>
</ul>
<h3 id="opening-the-serial-monitor"><a class="header" href="#opening-the-serial-monitor">Opening the Serial Monitor</a></h3>
<p>The serial monitor lets you see the debug output from your ESP32 in real-time.</p>
<ol>
<li>
<p><strong>Open the serial monitor</strong>:</p>
<ul>
<li>In PROJECT TASKS → <strong>esp32doit-devkit-v1</strong>, click <strong>Monitor</strong></li>
<li>Or click the plug icon (🔌) in the bottom toolbar</li>
<li>Or press <code>Ctrl+Alt+S</code> / <code>Cmd+Alt+S</code></li>
</ul>
</li>
<li>
<p><strong>The serial monitor opens</strong> in a new terminal panel at the bottom of VS Code</p>
</li>
<li>
<p><strong>If you missed the startup sequence</strong>, press the <strong>RESET</strong> button on your ESP32 board to restart it</p>
</li>
</ol>
<h3 id="verifying-the-output"><a class="header" href="#verifying-the-output">Verifying the Output</a></h3>
<p>You should see output similar to this:</p>
<pre><code>=== OpenLCB async_blink ESP32 Example ===
Node ID: 0x050201020200
Event 0: 0x0502010202000000
Event 1: 0x0502010202000001

Initializing SPIFFS...
SPIFFS initialized successfully

Connecting to WiFi SSID: YourNetwork
.
WiFi connected!
IP Address: 192.168.1.100

Initializing OpenLCB configuration...

Starting OpenLCB stack...
OpenLCB node initialization complete!
Entering run mode - will alternate events every 1 second

Produced event: 0x0502010202000000 (state: 0)
Produced event: 0x0502010202000001 (state: 1)
Produced event: 0x0502010202000000 (state: 0)
Produced event: 0x0502010202000001 (state: 1)
...
</code></pre>
<p><strong>What to verify</strong>:</p>
<ul>
<li>✅ SPIFFS initializes successfully</li>
<li>✅ WiFi connects successfully (shows your network name and IP address)</li>
<li>✅ OpenLCB stack initializes</li>
<li>✅ Events alternate between <code>...00</code> and <code>...01</code> every second</li>
<li>✅ State toggles between <code>0</code> and <code>1</code></li>
</ul>
<h3 id="understanding-what-you-see"><a class="header" href="#understanding-what-you-see">Understanding What You See</a></h3>
<p>This output confirms your ESP32 is:</p>
<ol>
<li><strong>Connected to WiFi</strong>: The IP address shows it's on your network</li>
<li><strong>Running the OpenLCB stack</strong>: Node initialization completed successfully</li>
<li><strong>Producing events</strong>: The alternating event IDs prove the event production logic works</li>
<li><strong>Ready for network communication</strong>: The node is broadcasting these events on the OpenLCB network (you'll verify this with JMRI next)</li>
</ol>
<p><strong>Congratulations!</strong> You have a working OpenLCB node. The events are being broadcast over WiFi/TCP, but you can't see them on the network yet - that's what JMRI will show you in the next section.</p>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<p><strong>WiFi won't connect</strong> (stuck on dots):</p>
<ul>
<li>Verify WiFi credentials in code are correct</li>
<li>Check ESP32 is within range of your access point</li>
<li>Confirm your network is 2.4GHz (not 5GHz only)</li>
<li>Some corporate/school networks block device connections</li>
</ul>
<p><strong>No serial output at all</strong>:</p>
<ul>
<li>Verify <code>monitor_speed = 115200</code> is in your <code>platformio.ini</code> file</li>
<li>Try pressing RESET button on ESP32</li>
<li>Verify the serial monitor is connected to the correct port</li>
</ul>
<p><strong>Output is garbled/random characters</strong>:</p>
<ul>
<li>Wrong baud rate - ensure <code>monitor_speed = 115200</code> is in <code>platformio.ini</code></li>
<li>If you already added it, stop and restart the serial monitor</li>
<li>Bad USB cable or connection</li>
</ul>
<p><strong>&quot;Brownout detector triggered&quot; errors</strong>:</p>
<ul>
<li>Insufficient power from USB port</li>
<li>Try a different USB port or powered USB hub</li>
<li>This usually doesn't prevent operation, just a warning</li>
</ul>
<h2 id="testing-with-jmri"><a class="header" href="#testing-with-jmri">Testing with JMRI</a></h2>
<p>Now that your ESP32 is producing events, let's use JMRI (Java Model Railroad Interface) to monitor them on the network. JMRI acts as a &quot;traffic monitor&quot; that shows all OpenLCB messages, letting you verify your node is working correctly.</p>
<h3 id="what-is-jmri"><a class="header" href="#what-is-jmri">What is JMRI?</a></h3>
<p>JMRI is an open-source application suite for model railroading that includes comprehensive OpenLCB/LCC support. In JMRI 5.x, LccPro is the authoritative tool for LCC configuration and monitoring. For our purposes, we'll use JMRI to:</p>
<ul>
<li>Monitor all OpenLCB messages on the network via <strong>LCC Monitor</strong></li>
<li>See when nodes initialize (CID, RID, AMD messages)</li>
<li>Observe event production and consumption</li>
<li>View and configure node information via <strong>LccPro</strong></li>
<li>Verify your ESP32 is communicating correctly</li>
</ul>
<p>Think of it as a &quot;network packet sniffer&quot; for OpenLCB.</p>
<h3 id="installing-jmri"><a class="header" href="#installing-jmri">Installing JMRI</a></h3>
<ol>
<li>
<p><strong>Download JMRI</strong>:</p>
<ul>
<li>Visit <a href="https://www.jmri.org/">jmri.org</a></li>
<li>Click <strong>Download</strong> → Latest Production Release</li>
<li>Choose your operating system (Windows, macOS, or Linux)</li>
<li>Download and run the installer</li>
</ul>
</li>
<li>
<p><strong>System Requirements</strong>:</p>
<ul>
<li>JMRI <strong>5.12 or later</strong> (LccPro requires JMRI 5.12+; earlier versions use the older DecoderPro LCC tools)</li>
<li>Java 11 or newer (usually bundled with JMRI installer)</li>
<li>Windows 7+, macOS 10.14+, or Linux with X11</li>
<li>~500MB disk space</li>
</ul>
</li>
<li>
<p><strong>Install JMRI</strong>:</p>
<ul>
<li>Run the installer with default options</li>
<li>On macOS, you may need to allow the app in System Preferences → Security</li>
<li>On Linux, you may need to make the script executable: <code>chmod +x JMRI-installer.sh</code></li>
</ul>
</li>
</ol>
<h3 id="configuring-the-lcc-connection"><a class="header" href="#configuring-the-lcc-connection">Configuring the LCC Connection</a></h3>
<p>JMRI needs to know how to connect to your ESP32's TCP Hub on port 12021. Let's configure that connection.</p>
<ol>
<li><strong>Launch LccPro</strong>:
<ul>
<li>In JMRI, go to <strong>ESP32 LCC → LccPro</strong></li>
<li>If this is the <strong>first time</strong> you're running LccPro and you have <strong>no other connections</strong>, the LccPro Wizard appears automatically (see first image below)</li>
<li>If you <strong>already have at least one connection</strong> from DecoderPro or PanelPro, continue to step 2</li>
</ul>
</li>
</ol>
<p><img src="../images/LccPro_FirstConnection.png" alt="LccPro Wizard on first launch (no existing connections)" /></p>
<ol start="2">
<li>
<p><strong>Configure the connection settings</strong>:</p>
<p><strong>If using the Wizard</strong> (first-time launch):</p>
<ul>
<li>Enter the connection details in the Wizard form (see steps 3 below for field definitions)</li>
<li>Click <strong>Next</strong> to proceed</li>
</ul>
<p><strong>If you have existing connections</strong>:</p>
<ul>
<li>Click <strong>Edit → Preferences</strong> in the LccPro window</li>
<li>Click the <strong>Connections</strong> tab (in the left sidebar)</li>
<li>Click the <strong>+</strong> button (bottom left) to add a new connection</li>
</ul>
</li>
</ol>
<p><img src="../images/JMRI_Preferences.png" alt="JMRI Preferences dialog with Connections tab" /></p>
<ol start="3">
<li>
<p><strong>Enter the connection settings</strong>:</p>
<ul>
<li><strong>System manufacturer</strong>: Select <code>LCC</code> (this is the OpenLCB standard system name in JMRI)</li>
<li><strong>System connection</strong>: Select <code>CAN via GridConnect Network Interface</code></li>
<li><strong>Connection name</strong>: Enter <code>ESP32 LCC</code> (or any descriptive name)</li>
<li><strong>IP Address/Host Name</strong>: Enter the IP address displayed in your PlatformIO serial monitor window (look for the line &quot;IP Address: 192.168.x.x&quot; from your ESP32's startup output)</li>
<li><strong>TCP/UDP Port</strong>: Enter <code>12021</code></li>
<li><strong>Connection Protocol</strong>: Select <code>OpenLCB</code></li>
</ul>
</li>
<li>
<p><strong>Save settings</strong> (required for both Wizard and Preferences):</p>
<ul>
<li>Click <strong>Edit → Preferences</strong> in the LccPro window (if not already there)</li>
<li>Click <strong>Save</strong> at the bottom of the Preferences window</li>
<li>JMRI will prompt to restart - click <strong>Restart Now</strong></li>
</ul>
</li>
</ol>
<h3 id="monitoring-lcc-traffic"><a class="header" href="#monitoring-lcc-traffic">Monitoring LCC Traffic</a></h3>
<p>After JMRI restarts, let's open the message monitor to see your ESP32's events.</p>
<ol>
<li>
<p><strong>Open the LCC Monitor</strong>:</p>
<ul>
<li>Go to <strong>ESP32 LCC → Monitor Traffic</strong></li>
<li>A new window opens showing a live feed of LCC messages</li>
</ul>
</li>
<li>
<p><strong>Observe the event production</strong>:</p>
<ul>
<li>You should see alternating event reports appearing every second</li>
<li>Each event corresponds to the events your ESP32 is producing</li>
</ul>
</li>
</ol>
<p><img src="../images/Traffic_Monitor.png" alt="LCC Traffic Monitor showing alternating events" /></p>
<h3 id="viewing-node-properties-snip-information"><a class="header" href="#viewing-node-properties-snip-information">Viewing Node Properties (SNIP Information)</a></h3>
<p>You can verify that JMRI recognizes your ESP32 as a node on the network and view its SNIP (Simple Node Information Protocol) details using LccPro:</p>
<ol>
<li>
<p><strong>Open LccPro</strong>:</p>
<ul>
<li>In JMRI, go to <strong>ESP32 LCC → LccPro</strong></li>
<li>This opens the LCC configuration tool and displays the node list</li>
</ul>
</li>
<li>
<p><strong>Find your ESP32 node</strong>:</p>
<ul>
<li>You should see a node with the ID matching your code (<code>050201020200</code>)</li>
<li>The node list displays the SNIP (Simple Node Information Protocol) data:
<ul>
<li><strong>Name</strong>: <code>async_blink</code> (your node name from <code>config.h</code>)</li>
<li><strong>ID</strong>: <code>050201020200</code> (your node's unique OpenLCB identifier)</li>
<li><strong>Manufacturer</strong>: <code>OpenMRN</code></li>
<li><strong>Model</strong>: <code>async_blink</code></li>
<li><strong>Software</strong>: <code>1.00</code></li>
<li><strong>Description</strong>: The description from <code>SNIP_NODE_DESC</code></li>
</ul>
</li>
<li>This confirms the node initialized successfully with correct identity information</li>
</ul>
</li>
</ol>
<p><img src="../images/LccProNodes.png" alt="LccPro node list showing the async_blink node" /></p>
<blockquote>
<p><strong>Note</strong>: The <strong>Configure</strong> button in LccPro is for editing the node's configuration. We'll explore that in Chapter 5.</p>
</blockquote>
<h3 id="understanding-snip-vs-acdi-important"><a class="header" href="#understanding-snip-vs-acdi-important">Understanding SNIP vs ACDI (Important!)</a></h3>
<p>Now is a good time to understand the distinction between two types of node information in OpenLCB:</p>
<p><strong>SNIP (Simple Node Information Protocol)</strong>:</p>
<ul>
<li>Identifies <strong>what the device IS</strong> (manufacturer, model, hardware/software versions)</li>
<li><strong>Hardcoded in firmware</strong> (in <code>config.h</code> as <code>SNIP_STATIC_DATA</code>)</li>
<li><strong>Read-only</strong> - cannot be changed without recompiling</li>
<li>Displayed in <strong>LccPro → Identification tab</strong> when you view node properties</li>
<li>Examples: <code>OpenMRN</code> (manufacturer), <code>async_blink</code> (model)</li>
</ul>
<p><strong>ACDI (Abbreviated Configuration Description Information)</strong>:</p>
<ul>
<li>Stores <strong>layout identity</strong> - how YOU refer to the node in your model railroad</li>
<li><strong>Persistent in SPIFFS</strong> (can be modified via JMRI without recompiling)</li>
<li>User-editable through <strong>LccPro</strong></li>
<li>Includes fields like &quot;User Name&quot; (what you call the node) and &quot;Description&quot;</li>
<li>Examples: <code>Main Station Blinker</code>, <code>Yard Controller #3</code></li>
</ul>
<p>In this v0.1 example, both are initialized from <code>config.h</code> constants. In Chapter 5, you'll learn to make ACDI values editable through JMRI using the configuration interface.</p>
<h3 id="optional-view-events-as-sensors"><a class="header" href="#optional-view-events-as-sensors">Optional: View Events as Sensors</a></h3>
<p>Want to see your ESP32's events visualized as sensor states? You can create sensors in <strong>PanelPro</strong> that correspond to your event IDs.</p>
<p><strong>Important</strong>: For this section, you need to have <strong>PanelPro</strong> open. If you only have JMRI running:</p>
<ul>
<li>Select <strong>File → Open PanelPro</strong> to launch it</li>
</ul>
<p>Once PanelPro is open:</p>
<ol>
<li>
<p><strong>Open the Sensor Table</strong>:</p>
<ul>
<li>Go to <strong>Tools → Tables → Sensors</strong></li>
<li>The sensor table displays any configured LCC sensors</li>
</ul>
</li>
<li>
<p><strong>Add your first sensor</strong>:</p>
<ul>
<li>Click <strong>Add</strong> to create a new sensor</li>
<li>In the dialog:
<ul>
<li><strong>System Name</strong>: Enter the hardware address for your first event ID
<ul>
<li>For <code>EVENT_ID_0</code> (0x0502010202000000), type: <code>0502010202000000</code></li>
<li>JMRI will automatically add the <code>MS</code> prefix when you click Create</li>
</ul>
</li>
<li><strong>User Name</strong>: Enter <code>ESP32 Event 0</code> (or any descriptive name)</li>
</ul>
</li>
<li>Click <strong>Create</strong></li>
</ul>
</li>
<li>
<p><strong>Repeat for the second event</strong>:</p>
<ul>
<li>Click <strong>Add</strong> again</li>
<li><strong>System Name</strong>: Type <code>0502010202000001</code></li>
<li><strong>User Name</strong>: <code>ESP32 Event 1</code></li>
<li>Click <strong>Create</strong></li>
</ul>
</li>
<li>
<p><strong>Watch the sensors</strong>:</p>
<ul>
<li>Return to the sensor table</li>
<li>Verify the system names are correct:
<ul>
<li>Event 0 should show: <code>MS0502010202000000</code></li>
<li>Event 1 should show: <code>MS0502010202000001</code></li>
</ul>
</li>
<li>As your ESP32 produces alternating events, observe the sensor behavior:
<ul>
<li><strong>Expected behavior</strong>: The sensors will flash ACTIVE for a brief moment, then return to INACTIVE</li>
<li><strong>Why the brief flash?</strong>: JMRI uses an event timeout mechanism. When an event is received, the sensor becomes ACTIVE. If the same event isn't re-sent within the timeout window, the sensor automatically reverts to INACTIVE (a safety feature to prevent stale states if a node disappears from the network)</li>
<li><strong>Pattern</strong>: Since your ESP32 alternates between EVENT_ID_0 and EVENT_ID_1 every second, you should see:
<ul>
<li>Second 1: Sensor 0 flashes ACTIVE, Sensor 1 stays INACTIVE</li>
<li>Second 2: Sensor 1 flashes ACTIVE, Sensor 0 stays INACTIVE</li>
<li>Second 3: Sensor 0 flashes ACTIVE, and so on...</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="../images/Sensors.png" alt="LCC Sensors showing alternating ACTIVE states" /></p>
<p>This demonstrates the bidirectional nature of LCC - your JMRI sensors are consuming events produced by your ESP32!</p>
<h3 id="configuration--jmri-cdi-discovery"><a class="header" href="#configuration--jmri-cdi-discovery">Configuration &amp; JMRI: CDI Discovery</a></h3>
<p>When JMRI first connects to your ESP32, it automatically discovers what configuration options are available by requesting the <strong>CDI (Configuration Description Information)</strong> file. This file (generated in <code>init_openlcb_stack()</code> as <code>/spiffs/cdi.xml</code>) describes:</p>
<ul>
<li>What segments are available (Internal settings, User info, Device-specific parameters)</li>
<li>What fields can be edited in each segment</li>
<li>Data types (text, numbers, enums, etc.)</li>
<li>Constraints (min/max values, field lengths, etc.)</li>
</ul>
<p>In v0.1, the CDI is generated automatically from the <code>ConfigDef</code> structure in <code>config.h</code>. Your node currently exposes:</p>
<ul>
<li><strong>SNIP Identification</strong>: Manufacturer, model, hardware/software versions (read-only)</li>
<li><strong>ACDI User Info</strong>: Node name and description (editable, but changes aren't saved yet)</li>
<li><strong>Internal Configuration</strong>: Reserved space for future parameters</li>
</ul>
<p>When you view node properties in <strong>LccPro → Configure</strong>, JMRI uses this CDI to render the appropriate dialog fields.</p>
<p><strong>In Chapter 5</strong>, you'll:</p>
<ul>
<li>Add configurable parameters (like <code>EVENT_INTERVAL</code>) to the CDI</li>
<li>Implement <code>apply_configuration()</code> to save user changes to SPIFFS</li>
<li>Learn how to version your configuration schema for forward compatibility</li>
<li>Test configuration updates through LccPro</li>
</ul>
<p>For now, understand that your node is already <strong>capable</strong> of being configured via JMRI - we're just not modifying the configuration yet. The CDI file ensures JMRI knows what configuration options your node supports.</p>
<h3 id="troubleshooting-jmri-connection"><a class="header" href="#troubleshooting-jmri-connection">Troubleshooting JMRI Connection</a></h3>
<p><strong>JMRI shows &quot;Connection failed&quot; or &quot;No route to host&quot;</strong>:</p>
<ul>
<li>Verify the IP address matches what the ESP32 serial monitor showed</li>
<li>Ensure your computer and ESP32 are on the same WiFi network</li>
<li>Check firewall settings - allow Java/JMRI to access the network</li>
<li>Try pinging the ESP32: <code>ping 192.168.1.100</code> (use your ESP32's IP)</li>
</ul>
<p><strong>No messages appear in the monitor</strong>:</p>
<ul>
<li>Click <strong>Clear</strong> in the monitor to reset the display</li>
<li>Press RESET on the ESP32 to trigger initialization messages</li>
<li>Check the connection status at the bottom of the JMRI window (should show &quot;Connected&quot;)</li>
</ul>
<p><strong>Messages appear but events don't match</strong>:</p>
<ul>
<li>Verify the event IDs in your code match what you're looking for in JMRI</li>
<li>Check that you didn't modify the EVENT_ID constants</li>
</ul>
<p><strong>&quot;Connection lost&quot; after working initially</strong>:</p>
<ul>
<li>ESP32 may have rebooted or lost WiFi connection</li>
<li>Check the serial monitor for errors or WiFi reconnection attempts</li>
<li>ESP32's IP address may have changed if DHCP lease renewed</li>
</ul>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p><strong>Library not found during build:</strong></p>
<ul>
<li>Verify the <code>lib_deps</code> line in <code>platformio.ini</code> has no typos</li>
<li>Run <strong>PlatformIO: Clean</strong> from the command palette (<code>Ctrl+Shift+P</code>)</li>
<li>Rebuild the project</li>
</ul>
<p><strong>ESP32 not detected:</strong></p>
<ul>
<li>Check USB cable (must be data cable, not charge-only)</li>
<li>Install CP2102 or CH340 USB driver for your operating system</li>
<li>Try a different USB port</li>
</ul>
<p><strong>WiFi connection fails:</strong></p>
<ul>
<li>Verify SSID and password in code</li>
<li>Check that ESP32 is within range of access point</li>
<li>ESP32 only supports 2.4GHz WiFi (not 5GHz)</li>
</ul>
<p><strong>JMRI not seeing events:</strong></p>
<ul>
<li>Verify JMRI is configured for TCP GridConnect connection</li>
<li>Check that ESP32 and JMRI are on the same network</li>
<li>Verify the TCP server address and port in ESP32 code</li>
</ul>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next</a></h2>
<p>You've now built your first OpenLCB node with WiFi transport! </p>
<p><strong>In the next chapter</strong>, we'll explore:</p>
<ul>
<li>Adding physical GPIO inputs (buttons) and outputs (LEDs) to your breadboard</li>
<li>Modifying the code to respond to button presses and control LEDs</li>
<li>Understanding GPIO configuration and debouncing</li>
</ul>
<p><strong>Beyond that</strong>, future chapters will cover:</p>
<ul>
<li>Adding CAN hardware for traditional LCC bus communication</li>
<li>Advanced event handling and CDI (Configuration Description Information)</li>
<li>Memory configuration and parameter persistence</li>
<li>SNIP (Simple Node Information Protocol) for node identification</li>
<li>Train control and specialized protocols</li>
</ul>
<p>For now, experiment with your working node: modify event IDs, add more inputs/outputs, or integrate it with other OpenLCB devices via JMRI.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../02-start/monitoring-and-tools.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../04-gpio/gpio-hardware.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../02-start/monitoring-and-tools.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../04-gpio/gpio-hardware.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="../mermaid.min.js"></script>
                <script type="text/javascript" src="../mermaid-init.js"></script>
        
        
    </body>
</html>
