# T4.2 Configuration Update Service - Research Summary

**Date**: December 24, 2025  
**Scope**: Researching OpenLCB standards alignment with OpenMRNLite implementation  
**Document Purpose**: Consolidate findings from both standards/TN research and source code analysis to establish a complete understanding of the Configuration Update Service architecture, workflow, current implementation status, and identified gaps.

---

## Section 1: OpenLCB Standards Overview

### Key Standards and Technical Notes (6 Documents)

The Configuration Update Service is defined across multiple OpenLCB standards and technical notes:

| Document | Title | Key Focus |
|----------|-------|-----------|
| **S-9.7.4.1** | Configuration Description Information (CDI) | Defines CDI XML schema for configurable parameters |
| **S-9.7.4.2** | Memory Configuration Protocol | Defines datagram-based memory read/write protocol |
| **S-9.7.4.3** | Simple Node Information Protocol (SNIP) | Defines node identification and manufacturer info |
| **TN-9.7.4.1** | CDI Technical Note | Implementation guidance for CDI |
| **TN-9.7.4.2** | Memory Configuration TN | Implementation guidance for memory config |
| **TN-9.7.4.3** | SNIP Technical Note | Implementation guidance for SNIP |

### Core Concepts

**Configuration Description Information (CDI)**
- XML-based definition of all configurable parameters for a node
- Accessible via memory space `0xFF` (read-only)
- Defines parameter types, defaults, ranges, and groups
- Enables configuration tools (like JMRI) to discover and configure any node

**Memory Configuration Protocol**
- Datagram-based protocol for reading/writing configuration memory
- Supports 256 unique memory address spaces (0x00-0xFF)
- Standard memory spaces:
  - `0xFF`: CDI (read-only) - the configuration description XML
  - `0xFE`: All Memory - special space providing access to device's entire memory
  - `0xFD`: Configuration - application-specific writable config data
  - `0xFC`, `0xFB`: Additional application-specific spaces
  - `0xF0`, `0xF1`, `0xF2`: Standard spaces in some implementations

**Simple Node Information Protocol (SNIP)**
- Static information about the node (manufacturer, model, version, etc.)
- Accessible via memory space addressing
- Provides human-readable device identification

### State Transitions

The OpenLCB initialization model defines two node states:

```
┌──────────────────┐
│   Initialized    │◄─────────────────┐
│  (Ready to       │                  │
│   operate)       │                  │
└────────┬─────────┘                  │
         │                            │
    Node resets or         Node sends "Update
    configuration           Complete" message
    is updated              (after configuration
         │                  changes are written)
         ▼                            │
┌──────────────────┐                  │
│  Uninitialized   │──────────────────┘
│  (Cannot accept  │
│   normal traffic)│
└──────────────────┘
```

**Key State Behaviors**:
- **Initialized**: Node can participate in OpenLCB protocol, handle events, respond to queries
- **Uninitialized**: Node cannot handle incoming events; signals initialization incompleteness to the network
- **Node Initialization Complete Message**: Required to transition from Uninitialized → Initialized after config changes

---

## Section 2: Configuration Update Workflow

### Discovery → Retrieval → Modification → Activation Flow

The complete configuration lifecycle follows this sequence:

#### Phase 1: Discovery
```
Configuration Tool (e.g., JMRI)
        │
        ├─→ Query node for supported address spaces
        ├─→ Read space 0xFF (CDI) to discover configurable parameters
        ├─→ Determine parameter structure and constraints
        └─→ Present UI to user
```

#### Phase 2: Retrieval
```
Configuration Tool reads current configuration
        │
        ├─→ Memory read requests to space 0xFD (or custom 0xFC, 0xFB)
        ├─→ Datagram transport protocol carries data
        └─→ Configuration data reconstructed from datagrams
```

#### Phase 3: Modification
```
User modifies parameters in configuration tool UI
        │
        └─→ Configuration Tool builds new complete configuration in memory
```

#### Phase 4: Activation
```
Configuration Tool writes modified configuration back to node
        │
        ├─→ Memory write requests to space 0xFD
        ├─→ Node persists data to EEPROM/Flash
        ├─→ Configuration Tool sends COMMAND_UPDATE_COMPLETE
        │
        ├─→ Node transitions to Uninitialized state
        ├─→ Node triggers ConfigUpdateFlow (trigger_update())
        ├─→ All ConfigUpdateListener instances apply new configuration
        ├─→ Node sends "Node Initialization Complete" message
        │
        └─→ Node transitions back to Initialized state
```

### Key Messages

**COMMAND_UPDATE_COMPLETE** (Memory Config Datagram)
- Sent by configuration tool after all writes complete
- Triggers `ConfigUpdateService::trigger_update()`
- Signals node to apply configuration changes

**Node Initialization Complete** (Addressed Message)
- Sent by node after applying configuration
- Indicates node is ready to process events again
- Required by OpenLCB standard after configuration changes

### State Machine Details

The node's lifecycle with respect to configuration:

```
[Startup]
    │
    ├─→ Open configuration file (EEPROM/Flash)
    ├─→ Check version matches firmware
    │   ├─ YES: Proceed to load
    │   └─ NO: Trigger factory_reset() on all listeners
    │
    ├─→ Call ConfigUpdateFlow::init_flow()
    │   ├─→ For each registered ConfigUpdateListener:
    │   │   └─→ Call listener->apply_configuration(fd, initial_load=true)
    │   └─→ Collect reboot/reinit requirements
    │
    ├─→ If REBOOT_NEEDED: Restart node
    ├─→ If REINIT_NEEDED: Start NodeInitializeFlow
    │
    └─→ Send "Node Initialization Complete" message
        └─→ Transition to Initialized state

[Running - User Modifies Config via JMRI]
    │
    ├─→ JMRI sends memory write datagrams
    ├─→ Node persists to EEPROM
    │
    ├─→ JMRI sends COMMAND_UPDATE_COMPLETE
    │   └─→ Triggers trigger_update()
    │
    ├─→ Call ConfigUpdateFlow::trigger_update()
    │   ├─→ Reset state machine
    │   ├─→ For each registered ConfigUpdateListener:
    │   │   └─→ Call listener->apply_configuration(fd, initial_load=false)
    │   └─→ Collect reboot/reinit requirements
    │
    ├─→ If REBOOT_NEEDED: Restart node
    ├─→ If REINIT_NEEDED: Start NodeInitializeFlow
    │
    └─→ Send "Node Initialization Complete" message
```

---

## Section 3: OpenMRNLite Current Implementation

### Architecture: Publish-Subscribe Pattern

OpenMRNLite implements configuration updates using a publish-subscribe (observer) pattern:

```cpp
// Core interface: ConfigUpdateService (publisher)
class ConfigUpdateService : public Singleton<ConfigUpdateService>
{
    virtual void register_update_listener(ConfigUpdateListener *listener) = 0;
    virtual void unregister_update_listener(ConfigUpdateListener *listener) = 0;
    virtual void trigger_update() = 0;
};

// Core interface: ConfigUpdateListener (subscriber)
class ConfigUpdateListener : public QMember
{
    enum UpdateAction { UPDATED, REINIT_NEEDED, REBOOT_NEEDED };
    
    virtual UpdateAction apply_configuration(
        int fd, bool initial_load, BarrierNotifiable *done) = 0;
    virtual void factory_reset(int fd) = 0;
};
```

### ConfigUpdateFlow: State Machine Implementation

`ConfigUpdateFlow.hxx` and `ConfigUpdateFlow.cxx` implement the state machine that coordinates all listeners:

**Key Responsibilities**:
- Maintains singleton instance of ConfigUpdateService
- Manages registration/unregistration of listeners
- Iterates through all listeners sequentially on `trigger_update()`
- Tracks reboot/reinit requirements across all listeners
- Handles final actions (reboot or node reinit)

**State Machine Flow**:
```cpp
trigger_update()
    ├─→ STATE(call_next_listener)
    │   └─→ Pop next listener from queue
    │       └─→ STATE(call_listener) - call apply_configuration()
    │           └─→ Wait for listener to complete (BarrierNotifiable)
    │               └─→ Loop back to call_next_listener
    │
    ├─→ STATE(do_initial_load) - when trigger_update() called first time
    │   └─→ Process pendingListeners (initial load before refresh)
    │
    └─→ STATE(apply_action) - when all listeners processed
        ├─→ If needsReboot_: call reboot()
        ├─→ If needsReInit_: create ReinitAllNodes flow
        └─→ Exit state machine
```

**File Descriptor Management**:
- Opened once via `openmrn.open_file()` before startup
- Same FD used for all listener `apply_configuration()` calls
- Listeners use `lseek()` to access their config data

### Current Listener Implementations (7 Known Types)

| Listener Class | File | Purpose |
|---|---|---|
| **ConfiguredConsumer** | ConfiguredConsumer.hxx | Simple GPIO-based event consumer with CDI config |
| **ConfiguredPulseConsumer** | ConfiguredPulseConsumer.hxx | Event consumer that pulses GPIO for fixed duration |
| **ConfiguredProducer** | ConfiguredProducer.hxx | Simple GPIO-based event producer with CDI config |
| **ServoConsumer** | ServoConsumer.hxx | PWM servo control with configurable event IDs |
| **MultiConfiguredConsumer** | MultiConfiguredConsumer.hxx | Multiple consumers in one listener |
| **MultiConfiguredPC** | MultiConfiguredPC.hxx | Multiple producer/consumer pairs |
| **Esp32WiFiManager** | Esp32WiFiManager.cpp | WiFi configuration listener |

### How trigger_update() Is Called

**Call Site**: `MemoryConfigHandler.cpp` line 727-729

```cpp
case MemoryConfigDefs::COMMAND_UPDATE_COMPLETE:
{
    Singleton<ConfigUpdateService>::instance()->trigger_update();
    break;
}
```

**Full Call Chain**:
1. Configuration Tool (JMRI) sends `COMMAND_UPDATE_COMPLETE` datagram
2. `MemoryConfigHandler` datagram handler receives message
3. Handler calls `trigger_update()` on ConfigUpdateService singleton
4. ConfigUpdateFlow state machine starts (or queues if already running)
5. Each registered listener's `apply_configuration()` is called sequentially
6. Final `apply_action` state handles reboot/reinit requirements

---

## Section 4: Standards Compliance Analysis

### What IS Implemented Correctly ✅

- **Basic publish-subscribe pattern** for configuration listeners
- **Sequential listener iteration** during configuration updates
- **Asynchronous state machine** for non-blocking listener calls (BarrierNotifiable pattern)
- **File descriptor passing** to listeners for configuration access
- **Return code support** (UPDATED, REINIT_NEEDED, REBOOT_NEEDED)
- **Factory reset triggering** when version mismatch detected
- **Memory space registration** for 0xF0, 0xF1, 0xF2 via MemoryConfigHandler
- **COMMAND_UPDATE_COMPLETE handling** that triggers configuration refresh
- **Node Initialization Complete message** generation after config changes

### What IS Partially Implemented ⚠️

- **Configuration file versioning**: Exists but triggers complete factory reset on mismatch (no field migration)
- **Asynchronous listener support**: Framework exists (ERROR_AGAIN + Notifiable pattern) but rarely used
- **Listener dependency ordering**: No support; listeners iterate in insertion order only
- **Configuration validation**: No pre-write validation; garbage data can be written to EEPROM
- **Listener status reporting**: No mechanism for listeners to report individual success/failure

### What IS NOT Implemented ❌

- **Persistent initialized flag**: No way to distinguish first boot from reboot
- **Field-level migration**: No mechanism to map old config format to new on version change
- **Automatic default application**: New fields get 0xFF (uninitialized) not defaults
- **Listener dependency ordering**: No dependency or priority system between listeners
- **Listener status aggregation**: No way to determine which listeners successfully applied config
- **Configuration rollback**: No checkpoint/rollback if listener fails partway through
- **Partial updates**: Configuration updates are all-or-nothing for each listener
- **Listener timeout handling**: No timeout if listener's `apply_configuration()` never completes
- **CDI_FACTORY_RESET macro safety**: Macro can cause compile errors if not used with accessor types

---

## Section 5: Identified Gaps and Issues

### Critical Gaps

#### Gap 1: No Persistent Initialized Flag
**Problem**: Nodes cannot distinguish between first boot and a reboot.
- On first boot after factory reset, listeners don't know if this is initial setup or recovery
- `initial_load` flag is only true at process startup, not after EEPROM factory reset
- Listeners cannot implement "first-time setup" logic that differs from "restore from backup"

**Impact**: Nodes that need special first-boot behavior (e.g., wizard modes, special initialization sequences) must use other mechanisms

**Standards Position**: OpenLCB expects nodes to track initialization state persistently

#### Gap 2: No Field Migration on Version Changes
**Problem**: When firmware version changes, entire configuration is wiped.
- Old config format is completely lost
- New fields appear as 0xFF (uninitialized)
- No mapping mechanism exists to preserve compatible fields
- Users lose all configuration when firmware updates

**Code Location**: `ConfigUpdateFlow.cxx` version check logic

**Impact**: 
- Users frustrated by lost configuration after updates
- No way to implement backward-compatible firmware changes
- Fields with defaults (0xFF) appear as garbage to listeners

**Example Scenario**:
```
v1.0 config: [EventID_1: 0x01.02.03.04.05.06.07.08] [Reserved: 0x00]
        ↓ firmware update
v2.0 config: [EventID_1: ???] [EventID_2: 0xFF] [Reserved: ???]
                             (lost, now uninitialized)
```

#### Gap 3: No Configuration Validation
**Problem**: Any data can be written to configuration memory.
- No validation of event IDs, node IDs, or other values
- Listeners receive garbage data and must handle/recover themselves
- No pre-write validation in memory config handler
- No rollback if listener fails due to bad data

**Impact**: 
- Corrupted configs can prevent node from functioning
- Hard to debug when user enters invalid config values
- No protection against malformed network datagrams

#### Gap 4: No Listener Dependency Ordering
**Problem**: Listeners execute in registration order, not dependency order.
- No way to specify "Listener A must run before Listener B"
- Some listeners may depend on others' state (e.g., GPIO allocation)
- Can cause initialization failures if run in wrong order

**Example**: 
```cpp
// These must run in specific order:
listener1.register(); // Allocates GPIO 5
listener2.register(); // Uses GPIO 5 from listener1
// But if listener2 registered first, listener1 might allocate GPIO 5 to different purpose
```

#### Gap 5: No Listener Status Reporting
**Problem**: ConfigUpdateFlow doesn't report individual listener success.
- Only aggregates REBOOT_NEEDED and REINIT_NEEDED flags
- No way to determine which listener failed
- Log messages must include listener name (hardcoded by each listener)

**Impact**:
- Hard to debug which listener caused config update failure
- No telemetry on configuration update success/failure
- Cannot report per-listener status back to configuration tool

#### Gap 6: No Asynchronous Config Support
**Problem**: Framework supports async via ERROR_AGAIN but almost never used.
- Most listeners implement blocking reads in `apply_configuration()`
- Async operations (like network fetches) not practical
- Notifiable wait pattern sufficient but complex to use correctly

**Impact**:
- Listeners that need to fetch configuration from cloud services must block
- Slow network operations stall entire config update
- Difficult to implement sophisticated listeners

### Standards Alignment Issues

| Issue | Standard Requirement | OpenMRNLite Implementation | Status |
|-------|----------------------|---------------------------|--------|
| **Initialization State** | Node tracks if uninitialized/initialized | Only process-level flag, not persistent | ⚠️ Partial |
| **Update Complete Signal** | Send Node Init Complete after config changes | Implemented via ReinitAllNodes | ✅ Complete |
| **Memory Spaces** | Support 0xFF (CDI), 0xFE (All), 0xFD (Config) | Supported via MemoryConfigHandler | ✅ Complete |
| **Datagram Protocol** | Memory read/write via datagrams | Implemented in DatagramHandler | ✅ Complete |
| **Version Tracking** | Version in config space | Implemented but resets on mismatch | ✅ Complete |
| **CDI XML Format** | CDI must be valid XML | Depends on application | Varies |
| **Factory Reset** | Support factory reset command | Implemented on version mismatch | ✅ Complete |

---

## Section 6: Memory Space Implementation Details

### Standard Memory Space Registration

OpenMRNLite's `MemoryConfigHandler` manages memory spaces for configuration access:

**Space 0xFF - Configuration Description (Read-Only)**
- Contains CDI XML data
- Automatically served by MemoryConfigHandler
- Defines all configurable parameters

**Space 0xFE - All Memory (Variable Access)**
- Provides access to full device memory
- Optional; designer-defined scope
- Implementation-specific

**Space 0xFD - Configuration (Writable)**
- Main configuration data space
- Application-specific structure
- Writes trigger memory config handler

**Space 0xF0, 0xF1, 0xF2 - Alternative Configuration Spaces**
- Some implementations use additional spaces:
  - 0xF0: Configuration (same as 0xFD)
  - 0xF1: Node Info (SNIP)
  - 0xF2: CDI Definition

### MemoryConfigHandler Role

`MemoryConfigHandler.cpp` implements the server side of memory config protocol:

```cpp
class MemoryConfigHandler : public DatagramHandlerDefault
{
    // Handles datagram messages for memory operations
    
    // Datagram commands:
    // - CMD_READ: Read from address space
    // - CMD_WRITE: Write to address space
    // - CMD_GET_CONFIG: Get space size/info
    // - CMD_UPDATE_COMPLETE: Trigger configuration refresh
    // - CMD_FACTORY_RESET: Trigger factory reset
};
```

**Write Flow for Space 0xF0 (Configuration)**:
```
Datagram Write Request (space=0xFD, addr=0, data=[...])
        ↓
MemoryConfigHandler.handle_datagram()
        ↓
Find registered MemorySpace for 0xFD
        ↓
Call MemorySpace.write(address, data)
        ↓
Data persisted to EEPROM/Flash
        ↓
(If all writes complete)
        ↓
Configuration Tool sends COMMAND_UPDATE_COMPLETE
        ↓
MemoryConfigHandler detects command
        ↓
Calls ConfigUpdateService::trigger_update()
```

### Space Allocation in OpenMRNLite Applications

Typical application setup:

```cpp
// In config.h or main.cpp:

// Define memory space for CDI (automatic)
// 0xFF = CDI XML (read-only, auto-served)

// Define memory space for configuration
// 0xFD = Application config struct (registered via accessor)

// Example from async_blink_esp32:
// - Space 0xFD: 128 bytes (config structure)
// - Accessed via ConfigUpdateFlow with EEPROM FD
```

---

## Section 7: File Location Reference

### Core Components Table

| Component | File | Key Lines | Purpose |
|-----------|------|-----------|---------|
| **ConfigUpdateService** | OpenMRNLite/src/utils/ConfigUpdateService.hxx | 40-65 | Virtual interface for service |
| **ConfigUpdateListener** | OpenMRNLite/src/utils/ConfigUpdateListener.hxx | 51-113 | Virtual interface for listeners |
| **DefaultConfigUpdateListener** | OpenMRNLite/src/utils/ConfigUpdateListener.hxx | 104-113 | Base class with auto-registration |
| **ConfigUpdateFlow** | OpenMRNLite/src/openlcb/ConfigUpdateFlow.hxx/cxx | 60-221 | State machine implementation |
| **MemoryConfigHandler** | OpenMRNLite/src/openlcb/MemoryConfigHandler.cxx | 1-1142 | Memory protocol handler |
| **COMMAND_UPDATE_COMPLETE** | OpenMRNLite/src/openlcb/MemoryConfigHandler.cxx | 727-729 | Trigger point |
| **ConfiguredConsumer** | OpenMRNLite/src/openlcb/ConfiguredConsumer.hxx | 87-141 | Example listener - GPIO consumer |
| **ConfiguredProducer** | OpenMRNLite/src/openlcb/ConfiguredProducer.hxx | 95+ | Example listener - GPIO producer |
| **ServoConsumer** | OpenMRNLite/src/openlcb/ServoConsumer.hxx | 16-111 | Example listener - PWM servo |

### Standards Documents

| Standard | File | Key Sections |
|----------|------|--------------|
| **Memory Configuration** | markdown/standards/S-9.7.4.2-MemoryConfiguration-2024-07-22.md | 4.1-4.3 Address spaces, 4.4-4.6 Commands |
| **CDI** | markdown/standards/S-9.7.4.1-ConfigurationDescriptionInformation-2024-07-22.md | XML schema, parameter types |
| **SNIP** | markdown/standards/S-9.7.4.3-SimpleNodeInformation-2024-07-22.md | Node identification format |
| **Memory Config TN** | markdown/standards/TN-9.7.4.2-MemoryConfiguration-2024-07-22.md | Implementation notes, examples |

---

## Section 8: Critical Research Findings

### Finding 1: Version Mismatch = Complete Config Wipe

**Discovery**: Detailed analysis of `ConfigUpdateFlow.cxx` version checking

When `CANONICAL_VERSION` differs from saved config file version:
- **Effect**: Complete factory reset triggered
- **Scope**: ENTIRE configuration wiped (except ACDI bytes 0-127 preserved)
- **Frequency**: Happens on every reboot if versions mismatch
- **Recovery**: None; users lose configuration

**Code Evidence**:
```cpp
if (!reset && cfg.version().read(fd) != expected_version) {
    LOG(VERBOSE, "config version mismatch (%d vs %d), forcing reset.",
        current_version, expected_version);
    reset = true;  // ← Triggers factory_reset() on all listeners
}
```

**Implications**:
- Firmware updates frequently reset user configuration
- No migration path for old config formats
- Fields added in new version appear uninitialized (0xFF)

### Finding 2: No Way to Distinguish First Boot from Reboot

**Discovery**: Analysis of initialization flow shows single-level state tracking

The OpenLCB standard requires nodes to track "initialized" state (ready to process events) vs "uninitialized" (configuration in progress). However:

- `initial_load` flag passed to listeners is set **only at process startup**
- Factory reset does NOT re-trigger `initial_load=true`
- Once process has started, `initial_load=false` for all subsequent config updates
- No persistent flag records "this is the first time this node has ever booted"

**Impact**:
- Listeners cannot implement "first-time setup" differently from "configuration restore"
- Impossible to detect if user is on first boot or rebooting after crash
- No way to populate EEPROM with defaults on very first power-up

### Finding 3: Listeners Iterate Sequentially with No Dependency Ordering

**Discovery**: `ConfigUpdateFlow.cxx` line 133-142

```cpp
Action call_next_listener() {
    // Pop listeners in FIFO order from queue
    if (nextRefresh_ == listeners_.end())
        return call_immediately(STATE(do_initial_load));
    
    l = nextRefresh_.operator->();
    ++nextRefresh_;
}
```

**How It Works**:
- Listeners stored in `std::list`
- Queue is simple FIFO - first registered, first executed
- **No dependency information tracked**
- Iterator walks queue linearly

**Problem Scenario**:
```
Listener A registered first (allocates GPIO 5)
Listener B registered second (uses GPIO 5)

But if B registered first:
  B allocates GPIO 5 for different purpose
  A's allocation fails or conflicts
  → Configuration fails
```

**Missing Feature**: Need dependency declaration system or explicit ordering control

### Finding 4: Asynchronous Support Exists But Rarely Used

**Discovery**: Analysis of listener implementations shows pattern but minimal usage

The framework supports truly asynchronous `apply_configuration()`:

```cpp
virtual UpdateAction apply_configuration(
    int fd, bool initial_load, BarrierNotifiable *done)
{
    // Can return UPDATED immediately
    // Or return ERROR_AGAIN to continue later
    // Then call done->notify() when ready
}
```

**Current Usage**:
- Almost all listeners use `AutoNotify n(done)` wrapper
- This calls `done->notify()` immediately in destructor
- Effectively makes every listener synchronous
- Only a handful of listeners actually use async pattern

**Why It Matters**:
- Async support is there for listeners needing network I/O
- Listeners could fetch config from cloud and apply it
- But complex enough that most devs just block on reads
- Performance suffers if EEPROM reads are slow

### Finding 5: No Status Reporting Per Listener

**Discovery**: ConfigUpdateFlow aggregates return codes but loses granularity

When `trigger_update()` runs, each listener returns:
- `UPDATED` - configuration applied successfully
- `REINIT_NEEDED` - node needs to rescan events
- `REBOOT_NEEDED` - node needs to restart

ConfigUpdateFlow implementation:
```cpp
switch (action) {
    case ConfigUpdateListener::UPDATED:
        break;  // ← No tracking of which listener
    case ConfigUpdateListener::REINIT_NEEDED:
        needsReInit_ = 1;  // ← Simple flag, no listener info
        break;
    case ConfigUpdateListener::REBOOT_NEEDED:
        needsReboot_ = 1;  // ← Simple flag, no listener info
        break;
}
```

**Limitation**: 
- No way to know which listener failed
- Configuration tool cannot report per-listener status
- Debugging which component has issue is hard
- No telemetry on config update success rates

### Finding 6: CDI_FACTORY_RESET Macro Has Usability Issues

**Discovery**: Examination of listener implementations

```cpp
void factory_reset(int fd) OVERRIDE {
    CDI_FACTORY_RESET(cfg_.servo_min_percent);
    CDI_FACTORY_RESET(cfg_.servo_max_percent);
}
```

**Issue**: 
- Macro requires accessor object (like `cfg_.servo_min_percent`)
- If used with wrong type, compile error is cryptic
- No automatic collection of all fields needing reset
- Must manually call for each field
- Easy to forget a field when adding new config parameters

**Better Alternative**: 
- Factory reset method should be auto-generated from CDI
- Or provide memset-like factory reset for entire config block
- Or track "reset defaults" per field in accessor

---

## Section 9: Recommendations for T4.2 Task

### Documentation Needs

For the T4.2 research document, prioritize:

1. **Configuration Update Flow Diagram**
   - Visual representation of listener iteration
   - State transitions (discovery → retrieval → modification → activation)
   - COMMAND_UPDATE_COMPLETE trigger point

2. **Listener Interface Documentation**
   - What `apply_configuration()` must do
   - When to return UPDATED vs REINIT_NEEDED vs REBOOT_NEEDED
   - File descriptor usage patterns
   - Error handling expectations

3. **Configuration Storage Layout**
   - Memory space allocation (0xFE, 0xFD, 0xFC, 0xFB)
   - CDI structure in space 0xFF
   - Version field location
   - ACDI data preservation (bytes 0-127)

4. **First Boot vs Reboot Detection**
   - Current limitation explained
   - Workarounds available
   - Suggested improvements

5. **Listener Registration Patterns**
   - When to register (before stack init, in constructor)
   - Dependency ordering issues
   - Constructor-time registration vs deferred registration

### Gaps That Should Be Addressed

**High Priority** (Impact user experience):
1. **Field migration on version change** - Users losing config is frustrating
2. **Persistent initialization flag** - Cannot implement proper first-boot logic
3. **Per-listener status reporting** - Hard to debug config failures

**Medium Priority** (Impact implementation quality):
4. **Listener dependency ordering** - Some complex applications need this
5. **Configuration validation** - Prevent garbage data corruption
6. **Listener timeout handling** - Stalled listeners should not freeze entire node

**Lower Priority** (Niche use cases):
7. **Enhanced async support** - Only needed for cloud-based listeners
8. **Configuration rollback** - Would require significant architecture change

### Suggested Future Improvements

#### Improvement 1: Add Persistent Initialization Tracking
```cpp
// Add to ConfigUpdateFlow:
// - Track in EEPROM whether node has ever fully initialized
// - Pass "is_first_boot_ever" flag to listeners
// - Allows special first-time setup logic
```

#### Improvement 2: Implement Field-Level Migration
```cpp
// Add to CDI:
// - Version tracking per field, not just overall
// - Migration functions that map old fields to new
// - Example: EventID_v1 (8 bytes) → EventID_v2 (8 bytes) + EventID2 (8 bytes)
```

#### Improvement 3: Add Listener Dependencies
```cpp
// Extend ConfigUpdateListener:
// - declare_dependency(ListenerType* other)
// - ConfigUpdateFlow respects dependency ordering
// - Listeners run topologically sorted, not FIFO
```

#### Improvement 4: Per-Listener Status Reporting
```cpp
// Enhance return codes:
// - Add ConfigUpdateResult struct with listener name + status
// - ConfigUpdateFlow collects all results
// - Can be queried after trigger_update() completes
```

---

## Section 10: Appendix: Key Code Examples

### Example 1: ConfiguredConsumer - Simple Listener Implementation

```cpp
class ConfiguredConsumer : public ConfigUpdateListener
{
public:
    template <class HW>
    ConfiguredConsumer(Node *node, const ConsumerConfig &cfg, 
                      const HW &, const Gpio* g = HW::instance())
        : impl_(node, 0, 0, g)
        , consumer_(&impl_)
        , cfg_(cfg)
    {
        // Auto-register with ConfigUpdateService
        ConfigUpdateService::instance()->register_update_listener(this);
    }

    // Called when configuration is loaded or updated
    UpdateAction apply_configuration(int fd, bool initial_load,
                                     BarrierNotifiable *done) OVERRIDE
    {
        AutoNotify n(done);  // Notify when exiting scope
        
        // Read event IDs from EEPROM via accessor
        EventId cfg_event_on = cfg_.event_on().read(fd);
        EventId cfg_event_off = cfg_.event_off().read(fd);
        
        // Check if configuration actually changed
        if (cfg_event_off != impl_.event_off() ||
            cfg_event_on != impl_.event_on())
        {
            // In-place destruction and reconstruction to update event handlers
            auto saved_gpio = impl_.gpio_;
            auto saved_node = impl_.node();
            consumer_.~BitEventConsumer();
            impl_.Impl::~Impl();
            
            // Reconstruct with new event IDs
            new (&impl_)
                Impl(saved_node, cfg_event_on, cfg_event_off, saved_gpio);
            new (&consumer_) BitEventConsumer(&impl_);
            
            return REINIT_NEEDED;  // Node needs to re-advertise events
        }
        return UPDATED;  // No change needed
    }

    void factory_reset(int fd) OVERRIDE
    {
        // Clear description field to defaults
        cfg_.description().write(fd, "");
    }
};
```

**Key Patterns**:
- Constructor calls `register_update_listener(this)`
- Uses `AutoNotify n(done)` for RAII notification handling
- Reads config via `cfg_.field().read(fd)`
- Returns `REINIT_NEEDED` if event IDs change
- `factory_reset()` resets fields via `CDI_FACTORY_RESET` macro

### Example 2: ServoConsumer - Complex PWM Reconstruction

```cpp
class ServoConsumer : public DefaultConfigUpdateListener
{
public:
    ServoConsumer(Node *node, const ServoConsumerConfig &cfg,
        const uint32_t pwmCountPerMs, PWM *pwm)
        : pwm_(pwm)
        , pwmGpo_(nullptr)
        , gpioImpl_(node, 0, 0, DummyPinWithRead())
        , consumer_(&gpioImpl_)
        , cfg_(cfg)
    {
        // Constructor-based registration via DefaultConfigUpdateListener
    }

    UpdateAction apply_configuration(int fd, bool initial_load,
                                     BarrierNotifiable *done) OVERRIDE
    {
        AutoNotify n(done);

        // Read all servo configuration parameters
        const EventId cfg_event_min = cfg_.event_rotate_min().read(fd);
        const EventId cfg_event_max = cfg_.event_rotate_max().read(fd);
        const int16_t cfg_servo_min_pct = cfg_.servo_min_percent().read(fd);
        const int16_t cfg_servo_max_pct = cfg_.servo_max_percent().read(fd);

        // Calculate PWM tick counts from percentages
        const uint32_t servo_ticks_0 = pwmCountPerMs_ * 1;    // 1ms
        const uint32_t servo_ticks_180 = pwmCountPerMs_ * 2;  // 2ms

        const uint32_t cfg_srv_ticks_min =
            ((100 - cfg_servo_min_pct) * servo_ticks_0 +
                cfg_servo_min_pct * servo_ticks_180) / 100;
        const uint32_t cfg_srv_ticks_max =
            ((100 - cfg_servo_max_pct) * servo_ticks_0 +
                cfg_servo_max_pct * servo_ticks_180) / 100;

        // Preserve current GPIO state across reconstruction
        const bool was_set = pwmGpo_ && (pwmGpo_->read() == Gpio::SET);

        // Check if anything actually changed
        if (!pwmGpo_ ||
            cfg_event_min != gpioImpl_.event_off() ||
            cfg_event_max != gpioImpl_.event_on() ||
            cfg_srv_ticks_min != pwmGpo_->get_off_counts() ||
            cfg_srv_ticks_max != pwmGpo_->get_on_counts())
        {
            auto saved_node = gpioImpl_.node();

            // In-place destruction and reconstruction
            consumer_.~BitEventConsumer();
            gpioImpl_.~GPIOBit();

            // Create new PWM GPIO with updated tick counts
            pwmGpo_.reset(new PWMGPO(pwm_,
                /*on_counts=*/cfg_srv_ticks_max,
                /*off_counts=*/cfg_srv_ticks_min));
            pwmGpo_->write(was_set ? Gpio::SET : Gpio::CLR);

            // Reconstruct event handler with new event IDs
            new (&gpioImpl_) GPIOBit(
                saved_node, cfg_event_min, cfg_event_max, pwmGpo_.get());
            new (&consumer_) BitEventConsumer(&gpioImpl_);

            return REINIT_NEEDED;
        }
        return UPDATED;
    }
};
```

**Advanced Patterns**:
- Reads multiple related parameters atomically
- Performs calculations based on configuration
- Reconstructs multiple objects in-place
- Preserves state (GPIO level) across reconstruction
- Returns REINIT_NEEDED for servo parameter changes

### Example 3: trigger_update() Call Chain

**Initiation** - `MemoryConfigHandler.cpp`:
```cpp
case MemoryConfigDefs::COMMAND_UPDATE_COMPLETE:
{
    Singleton<ConfigUpdateService>::instance()->trigger_update();
    break;
}
```

**State Machine Entry** - `ConfigUpdateFlow.cxx`:
```cpp
void trigger_update() override
{
    AtomicHolder h(this);
    nextRefresh_ = listeners_.begin();  // Reset iterator
    needsReboot_ = 0;
    needsReInit_ = 0;
    
    if (is_state(exit().next_state()))  // If not already running
    {
        start_flow(STATE(call_next_listener));  // Start state machine
    }
}
```

**Listener Iteration** - `ConfigUpdateFlow.cxx`:
```cpp
Action call_next_listener()
{
    ConfigUpdateListener *l = nullptr;
    {
        AtomicHolder h(this);
        if (nextRefresh_ == listeners_.end())
        {
            return call_immediately(STATE(do_initial_load));  // All listeners done
        }
        l = nextRefresh_.operator->();
        ++nextRefresh_;  // Move to next listener
    }
    return call_listener(l, false);  // Call this listener
}
```

**Listener Callback** - `ConfigUpdateFlow.cxx`:
```cpp
Action call_listener(ConfigUpdateListener *l, bool is_initial)
{
    if (fd_ < 0)
    {
        DIE("CONFIG_FILENAME not specified");
    }
    
    // Call listener's apply_configuration method
    ConfigUpdateListener::UpdateAction action =
        l->apply_configuration(fd_, is_initial, n_.reset(this));
    
    // Track what listener requested
    switch (action)
    {
        case ConfigUpdateListener::UPDATED:
            break;  // No special action
        case ConfigUpdateListener::REINIT_NEEDED:
            needsReInit_ = 1;
            break;
        case ConfigUpdateListener::REBOOT_NEEDED:
            needsReboot_ = 1;
            break;
    }
    
    return wait();  // Wait for listener to call done->notify()
}
```

**Final Actions** - `ConfigUpdateFlow.cxx`:
```cpp
Action apply_action()
{
    // Execute required actions based on listener requests
    if (needsReboot_)
    {
#if OPENMRN_FEATURE_REBOOT
        reboot();  // Hard reboot the entire node
#endif
    }
    
    if (needsReInit_)
    {
        // Start Node Initialization Complete message flow
        new ReinitAllNodes(static_cast<If *>(service()));
    }
    
    return exit();  // State machine done
}
```

**Complete Call Sequence**:
```
Configuration Tool sends COMMAND_UPDATE_COMPLETE datagram
    ↓
MemoryConfigHandler receives datagram
    ↓
Calls trigger_update()
    ↓
ConfigUpdateFlow::trigger_update() invoked
    ↓
STATE(call_next_listener) entered
    ↓
For each listener:
    call_listener(listener, is_initial=false)
        ↓
        listener->apply_configuration(fd, false, done)
            ↓
            Listener reads config from fd
            Listener applies new configuration
            Listener calls done->notify() via AutoNotify destructor
        ↓
    Returns UPDATED/REINIT_NEEDED/REBOOT_NEEDED
    ↓
Next listener processed
    ↓
STATE(do_initial_load)
    ↓
STATE(apply_action)
    ↓
If needsReboot_: reboot()
If needsReInit_: Start ReinitAllNodes
    ↓
Exit state machine
```

### Example 4: COMMAND_UPDATE_COMPLETE Handling

**Datagram Reception** - `MemoryConfigHandler.cpp`:

```cpp
Action handle_write_datagram() {
    uint8_t command = payload[1] & MemoryConfigDefs::COMMAND_MASK;
    
    switch (command) {
        case MemoryConfigDefs::COMMAND_WRITE:
            // ... process write to address space
            
        case MemoryConfigDefs::COMMAND_READ:
            // ... process read from address space
            
        case MemoryConfigDefs::COMMAND_UPDATE_COMPLETE:
        {
            // Trigger configuration update on all listeners
            Singleton<ConfigUpdateService>::instance()->trigger_update();
            break;
        }
        
        case MemoryConfigDefs::COMMAND_FACTORY_RESET:
        {
            // Trigger factory reset on all listeners
            updateService_->factory_reset();
            break;
        }
    }
}
```

**Key Point**: 
- COMMAND_UPDATE_COMPLETE is received as part of datagram
- Causes immediate `trigger_update()` call
- Asynchronous state machine starts
- Configuration tool doesn't wait for completion
- Node sends "Node Initialization Complete" message when ready

---

## Summary

The Configuration Update Service is a sophisticated publish-subscribe system enabling runtime configuration of OpenLCB nodes. The OpenMRNLite implementation provides:

- ✅ Robust state machine for sequential listener execution
- ✅ Asynchronous operation support via Notifiable pattern
- ✅ Full datagram protocol support for memory operations
- ✅ Factory reset capabilities
- ✅ Version tracking and mismatch detection

However, gaps remain in:
- ❌ Persistent initialization state tracking
- ❌ Field-level configuration migration
- ❌ Listener dependency ordering
- ❌ Per-listener status reporting
- ❌ Configuration validation

These gaps don't prevent basic operation but limit sophisticated use cases. T4.2 should document both the working implementation and these limitations for future improvement efforts.

---

**Document Last Updated**: December 24, 2025  
**Research Scope**: OpenMRNLite versions in LCC workspace + OpenLCB Standards S-9.7.4.x series
