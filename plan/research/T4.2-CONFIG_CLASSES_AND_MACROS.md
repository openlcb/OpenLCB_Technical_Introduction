# T4.2 OpenMRNLite Configuration Classes and Macros Reference

**Date:** December 25, 2025  
**Scope:** Complete reference for all OpenMRNLite configuration value types, macros, and patterns  
**Source:** OpenMRNLite codebase analysis

---

## Overview

OpenMRNLite uses a sophisticated compile-time CDI (Configuration Description Information) generation system based on C++ macros and template metaprogramming. This document catalogs:

1. **Basic Field Types** - Integer, boolean, multi-choice, event IDs, strings
2. **Advanced Constructs** - RepeatedGroup (arrays), nested groups, empty groups
3. **Macro Reference** - All CDI definition and runtime macros
4. **Memory and Storage** - Endianness, segment management, layout
5. **Integration Patterns** - ConfigUpdateListener, file descriptor usage

---

# PART 1: BASIC FIELD TYPES

## 1. Integer Configuration Values

### 1.1 Integer Field Types

OpenMRNLite provides typed aliases for numeric configuration entries, all based on the `NumericConfigEntry<T>` template:

#### Unsigned Integer Types:
```cpp
using Uint8ConfigEntry  = NumericConfigEntry<uint8_t>;    // 1 byte (0-255)
using Uint16ConfigEntry = NumericConfigEntry<uint16_t>;   // 2 bytes (0-65535)
using Uint32ConfigEntry = NumericConfigEntry<uint32_t>;   // 4 bytes (0-4294967295)
using Uint64ConfigEntry = NumericConfigEntry<uint64_t>;   // 8 bytes
```

#### Signed Integer Types:
```cpp
using Int8ConfigEntry  = NumericConfigEntry<int8_t>;      // 1 byte (-128 to 127)
using Int16ConfigEntry = NumericConfigEntry<int16_t>;     // 2 bytes (-32768 to 32767)
using Int32ConfigEntry = NumericConfigEntry<int32_t>;     // 4 bytes
using Int64ConfigEntry = NumericConfigEntry<int64_t>;     // 8 bytes
```

#### Special Integer Type:
```cpp
using EventConfigEntry = Uint64ConfigEntry;  // Specialized for 64-bit OpenLCB Event IDs
```

**File Location:** OpenMRNLite/src/openlcb/ConfigEntry.hxx (lines 330-350)

### 1.2 Integer Configuration Definition Syntax

#### Basic Integer Entry (with defaults and constraints):
```cpp
CDI_GROUP_ENTRY(servo_min_percent, Int16ConfigEntry,
    Default(0),           // Default value = 0
    Min(-99),             // Minimum allowed value = -99
    Max(200),             // Maximum allowed value = 200
    Name("Servo Min %"),
    Description("Minimum servo position as percentage"));
```

#### Another Example (Port Number):
```cpp
CDI_GROUP_ENTRY(port, Uint16ConfigEntry,
    Name("Port Number"),
    Description("TCP port number of the server"),
    Min(1),               // Port must be >= 1
    Max(65535),           // Port must be <= 65535
    Default(12021));      // Factory reset value
```

#### Integer with MapValues (Multi-Choice):
```cpp
static constexpr const char *SEARCH_MODE_MAP =
    "<relation><property>0</property><value>Auto, Manual</value></relation>"
    "<relation><property>1</property><value>Manual, Auto</value></relation>"
    "<relation><property>2</property><value>Auto Only</value></relation>"
    "<relation><property>3</property><value>Manual Only</value></relation>";

CDI_GROUP_ENTRY(search_mode, Uint8ConfigEntry,
    Name("Search Mode"),
    Default(0),
    Min(0), Max(3),
    MapValues(SEARCH_MODE_MAP),
    Description("Defines the order of how to locate the server"));
```

### 1.3 Memory Layout

- All numeric values are stored in **big-endian (network byte order)**
- The `NumericConfigEntry<TR>` template handles endian conversion automatically
- Size in configuration file = `sizeof(TR)` bytes
- Offset automatically calculated by CDI macro system
- Endian conversion functions defined for all integer types

**File Location:** OpenMRNLite/src/openlcb/ConfigEntry.hxx (lines 154-229)

### 1.4 Reading Integer Values in Code

#### Basic Read:
```cpp
// Assuming cfg is an instance of ConfigDef with cfg.seg().servo_min_percent()
uint8_t min_value = cfg.seg().servo_min_percent().read(fd);
```

#### With Trimming (Automatic Min/Max Enforcement):
```cpp
// If value is outside Min/Max constraints, overwrites file with trimmed value
uint16_t port = CDI_READ_TRIMMED(cfg.seg().port, fd);
```

#### With Default Value Fallback:
```cpp
// If value violates Min/Max constraints, overwrites file with default value
uint16_t my_value = CDI_READ_TRIM_DEFAULT(cfg.seg().my_entry, fd);
```

**File Location:** OpenMRNLite/src/openlcb/ConfigRepresentation.hxx (lines 336-360)

### 1.5 Writing Integer Values in Code

```cpp
// Basic write
cfg.seg().servo_min_percent().write(fd, 25);

// Factory reset to default value
CDI_FACTORY_RESET(cfg.seg().servo_min_percent);
```

**File Location:** OpenMRNLite/src/openlcb/ConfigEntry.hxx (lines 290-311)

### 1.6 Validation Patterns

The framework provides several validation approaches:

1. **Static Definition Constraints** (at CDI definition time):
   - `Min()` - Minimum acceptable value
   - `Max()` - Maximum acceptable value
   - `Default()` - Value to use on factory reset or validation failure

2. **Runtime Trimming** (on config read):
   - `read_or_write_trimmed()` - Clamps value to [Min, Max]
   - `read_or_write_default()` - Uses default if outside [Min, Max]

3. **Manual Validation** (in code):
   ```cpp
   int value = cfg.seg().some_value().read(fd);
   if (value < MY_MIN || value > MY_MAX) {
       // Handle error
   }
   ```

---

## 2. Boolean Configuration Values

### 2.1 Boolean Implementation

OpenMRNLite does **not have a dedicated boolean field type**. Booleans are implemented using:

**Option A: `Uint8ConfigEntry` with MapValues**
```cpp
static constexpr const char *BOOLEAN_MAP =
    "<relation><property>0</property><value>No</value></relation>"
    "<relation><property>1</property><value>Yes</value></relation>";

CDI_GROUP_ENTRY(enable_feature, Uint8ConfigEntry,
    Default(1),
    Min(0), Max(1),
    MapValues(BOOLEAN_MAP),
    Name("Enable Feature"),
    Description("Turn feature on or off"));
```

**Option B: Variable-Length BitField** (not common in CDI)
- Can use single bit within packed structures
- Requires manual bit extraction in code

### 2.2 Boolean Field Definition

```cpp
// In class parameter header
static constexpr const char *BOOLEAN_MAP =
    "<relation><property>0</property><value>No</value></relation>"
    "<relation><property>1</property><value>Yes</value></relation>";

// In CDI group
CDI_GROUP_ENTRY(wifi_power_save, Uint8ConfigEntry,
    Default(0),           // Default to disabled (No)
    Min(0), Max(1),
    MapValues(BOOLEAN_MAP),
    Name("WiFi Power Savings Mode"),
    Description("Enable power-saving mode..."));

CDI_GROUP_ENTRY(reconnect, Uint8ConfigEntry,
    Default(1),           // Default to enabled (Yes)
    Min(0), Max(1),
    MapValues(BOOLEAN_MAP),
    Name("Reconnect"),
    Description("Reconnect to last known good address"));
```

### 2.3 Reading Boolean Values

```cpp
// Read and interpret as boolean
uint8_t enabled = cfg.seg().enable_feature().read(fd);
if (enabled) {
    // Feature is enabled
}

// More idiomatic C++:
bool is_enabled = (cfg.seg().enable_feature().read(fd) != 0);
```

### 2.4 Writing Boolean Values

```cpp
// Write boolean state
cfg.seg().enable_feature().write(fd, 1);  // Enable
cfg.seg().enable_feature().write(fd, 0);  // Disable
```

### 2.5 Memory Layout

- **Storage:** 1 byte per boolean (Uint8ConfigEntry uses 1 byte)
- **Values:** 0 = No/False/Disabled, 1 = Yes/True/Enabled
- **Expansion:** User interfaces (JMRI) render as checkboxes or Yes/No dropdowns

---

## 3. Multi-Choice Configuration Values

### 3.1 MapValues Definition

Multi-choice configurations use the `MapValues()` option to provide a set of named options. The syntax is XML-based within string literals.

#### XML Format for MapValues:
```xml
<map>
  <relation>
    <property>VALUE1</property>
    <value>Label1</value>
  </relation>
  <relation>
    <property>VALUE2</property>
    <value>Label2</value>
  </relation>
</map>
```

#### In C++ Code:
```cpp
static constexpr const char *ACTION_MAP =
    "<relation><property>0</property><value>Output</value></relation>"
    "<relation><property>1</property><value>Input</value></relation>";
```

### 3.2 Complete Multi-Choice Example

```cpp
// In a parameters class
class PCConfigParams {
public:
    static constexpr const char *ACTION_MAP =
        "<relation><property>0</property><value>Output</value></relation>"
        "<relation><property>1</property><value>Input</value></relation>";

    enum class ActionConfig : uint8_t {
        DOUTPUT = 0,
        DINPUT = 1
    };
};

// In CDI group definition
CDI_GROUP(PCConfig);
CDI_GROUP_ENTRY(action, Uint8ConfigEntry,
    Default(1),
    MapValues(PCConfigParams::ACTION_MAP),
    Name("Configuration"),
    Description("Select Output or Input mode"));
CDI_GROUP_END();
```

### 3.3 Reading Multi-Choice Values

```cpp
uint8_t mode = cfg.seg().action().read(fd);

// Type-safe interpretation with enum
enum class ActionType : uint8_t {
    OUTPUT = 0,
    INPUT = 1
};

ActionType config_action = static_cast<ActionType>(mode);

switch (config_action) {
    case ActionType::OUTPUT:
        setup_as_output();
        break;
    case ActionType::INPUT:
        setup_as_input();
        break;
}
```

### 3.4 Writing Multi-Choice Values

```cpp
// Write by numeric value
cfg.seg().action().write(fd, 0);  // OUTPUT

// Or using enum
cfg.seg().action().write(fd, static_cast<uint8_t>(ActionType::INPUT));
```

### 3.5 Memory Layout

- **Storage:** Underlying integer type (usually Uint8ConfigEntry)
- **Values:** Numeric values mapped to user-friendly labels
- **Range:** Typically 0-3 for simple choices, can extend to 255 for Uint8
- **UI Rendering:** JMRI renders as dropdown menus with labeled options

### 3.6 Real-World Example: Connection Mode

```cpp
// From Esp32WiFiConfiguration.hxx
class Esp32WiFiConfigurationParams {
public:
    static constexpr const char *CONN_MODE_MAP =
        "<relation><property>0</property><value>Hub Only</value></relation>"
        "<relation><property>1</property><value>Uplink Only</value></relation>"
        "<relation><property>2</property><value>Both</value></relation>"
        "<relation><property>3</property><value>Disabled</value></relation>";

    enum class ConnectionMode : uint8_t {
        HUB_ONLY = 0,
        UPLINK_ONLY = 1,
        BOTH = 2,
        DISABLED = 3
    };
};

// CDI definition
CDI_GROUP_ENTRY(connection_mode, Uint8ConfigEntry,
    Default(2),  // Default: Both
    Min(0), Max(3),
    MapValues(CONN_MODE_MAP),
    Name("Connection Mode"),
    Description("Hub, Uplink, or Both"));
```

---

## 4. Event ID Configuration Values

### 4.1 EventConfigEntry Type

EventConfigEntry is a specialized variant of Uint64ConfigEntry designed specifically for OpenLCB 64-bit event identifiers.

```cpp
class EventConfigEntry : public Uint64ConfigEntry {
public:
    template <typename T>
    constexpr EventConfigEntry(T t)
        : Uint64ConfigEntry(t)
    {
    }

    static constexpr AtomConfigRenderer config_renderer()
    {
        return AtomConfigRenderer("eventid", AtomConfigRenderer::SKIP_SIZE);
    }

    void handle_events(const EventOffsetCallback& fn) {
        fn(offset());
    }
};
```

**File Location:** OpenMRNLite/src/openlcb/ConfigEntry.hxx (lines 340-352)

### 4.2 EventID Configuration Definition

```cpp
CDI_GROUP(ServoConsumerConfig);
CDI_GROUP_ENTRY(event_rotate_min, EventConfigEntry,
    Name("Minimum Rotation Event ID"),
    Description("Receiving this event ID will rotate the servo "
                "to its minimum configured point."));
CDI_GROUP_ENTRY(event_rotate_max, EventConfigEntry,
    Name("Maximum Rotation Event ID"),
    Description("Receiving this event ID will rotate the servo "
                "to its maximum configured point."));
CDI_GROUP_END();
```

### 4.3 Reading Event IDs

```cpp
// Read 64-bit event ID
uint64_t event_on = cfg.seg().event_on().read(fd);
uint64_t event_off = cfg.seg().event_off().read(fd);

// EventID format: 0xAABBCCDDEEFFGGHH
// Use with OpenLCB event handlers
node->register_event_consumer(event_on, consumer_handler);
```

### 4.4 Writing Event IDs

```cpp
// Factory reset EventID fields
CDI_FACTORY_RESET(cfg.seg().event_on);  // Reset to CDI default
CDI_FACTORY_RESET(cfg.seg().event_off);

// Or write specific value
uint64_t new_event_id = 0x0502010202000001ULL;
cfg.seg().event_on().write(fd, new_event_id);
```

### 4.5 Memory Layout

- **Storage:** 8 bytes (Uint64ConfigEntry)
- **Byte Order:** Big-endian (network order)
- **XML Tag:** `<eventid>` (not generic `<int>`)
- **Event Handler Tracking:** EventConfigEntry automatically registers offsets for event update callbacks

---

## 5. String Configuration Values

### 5.1 String Configuration Entry

String entries are templated by maximum size (including NULL terminator):

```cpp
using StringConfigEntry<SIZE> = StringConfigEntry<SIZE>;
```

### 5.2 String Configuration Definition

```cpp
CDI_GROUP_ENTRY(description, StringConfigEntry<16>,
    Name("Description"),
    Description("User name of this output"));

CDI_GROUP_ENTRY(ip_address, StringConfigEntry<32>,
    Name("IP Address"),
    Description("Enter the server IP address. Example: 192.168.0.55"));

CDI_GROUP_ENTRY(service_name, StringConfigEntry<48>,
    Name("mDNS Service"),
    Description("mDNS or Bonjour service name"));
```

### 5.3 Reading String Values

```cpp
#include <string>

// Read string from configuration
std::string description = cfg.seg().description().read(fd);
std::string ip_addr = cfg.seg().ip_address().read(fd);

// Returned std::string has trailing null removed
Serial.printf("Device: %s\n", description.c_str());
```

**File Location:** OpenMRNLite/src/openlcb/ConfigEntry.hxx (lines 377-391)

### 5.4 Writing String Values

```cpp
// Write string to configuration
cfg.seg().description().write(fd, "My Servo");
cfg.seg().ip_address().write(fd, "192.168.1.100");

// String is automatically truncated if too long (SIZE-1 max)
// Null terminator automatically appended
```

**File Location:** OpenMRNLite/src/openlcb/ConfigEntry.hxx (lines 393-396)

### 5.5 Memory Layout

- **Storage:** SIZE bytes total (SIZE-1 usable characters + null terminator)
- **Format:** C-string (null-terminated)
- **Truncation:** Strings longer than SIZE-1 are automatically truncated
- **Padding:** Remaining bytes are NOT cleared (may contain garbage)

---

# PART 2: ADVANCED CONSTRUCTS

## 6. RepeatedGroup / Arrays

### 6.1 What is RepeatedGroup<T, N>?

`RepeatedGroup<T, N>` is a template class that represents N repetitions of a configuration group of type T. It enables memory-efficient representation of repeated configuration entries (like multiple outputs, inputs, or servo controls).

**Definition Location**: OpenMRNLite/src/openlcb/ConfigRepresentation.hxx (line 359)

```cpp
template <class Group, unsigned N> class RepeatedGroup : public ConfigEntryBase
{
public:
    using base_type = ConfigEntryBase;
    INHERIT_CONSTEXPR_CONSTRUCTOR(RepeatedGroup, base_type)
    
    static constexpr unsigned size()
    {
        return Group::size() * N;
    }
    
    constexpr unsigned end_offset() const
    {
        return offset() + size();
    }
    
    static constexpr unsigned num_repeats()
    {
        return N;
    }
    
    template <int K> constexpr Group entry() const
    {
        static_assert(K < N, "Tried to fetch an entry of a repeated "
                             "group that does not exist!");
        return Group(offset_ + (K * Group::size()));
    }

    Group entry(unsigned k)
    {
        HASSERT(k < N);
        return Group(offset_ + (k * Group::size()));
    }

    static constexpr GroupConfigRenderer<Group> config_renderer()
    {
        return GroupConfigRenderer<Group>(N, Group(0));
    }

    void handle_events(const EventOffsetCallback &fn)
    {
        for (unsigned i = 0; i < N; ++i)
        {
            entry(i).handle_events(fn);
        }
    }
};
```

### 6.2 Real-World Usage Example

```cpp
// Define number of repeats
constexpr uint8_t NUM_OUTPUTS = 8;
constexpr uint8_t NUM_INPUTS = 8;

// Create repeated groups
using AllConsumers = RepeatedGroup<ConsumerConfig, NUM_OUTPUTS>;
using AllProducers = RepeatedGroup<ProducerConfig, NUM_INPUTS>;

// Use in CDI configuration
CDI_GROUP(IoBoardSegment, Segment(MemoryConfigDefs::SPACE_CONFIG), Offset(128));
CDI_GROUP_ENTRY(consumers, AllConsumers, Name("Outputs"), RepName("Output"));
CDI_GROUP_ENTRY(producers, AllProducers, Name("Inputs"), RepName("Input"));
CDI_GROUP_END();
```

### 6.3 Accessing Repeated Items

#### Compile-Time Access (Template)
```cpp
// Get 3rd entry at compile-time (0-indexed)
auto entry3 = config.producers().entry<2>();
```

#### Runtime Access
```cpp
// Iterate through all entries
for (unsigned i = 0; i < NUM_OUTPUTS; ++i)
{
    auto entry = config.consumers().entry(i);
    uint64_t event_on = entry.event_on().read(fd);
    uint64_t event_off = entry.event_off().read(fd);
    std::string desc = entry.description().read(fd);
}
```

### 6.4 Compile-Time vs Runtime Access

| Aspect | Compile-Time | Runtime |
|--------|--------------|---------|
| **Syntax** | `entry<N>()` | `entry(N)` |
| **Index Check** | Static assert | HASSERT |
| **Performance** | Zero overhead | Minimal overhead |
| **Use Case** | Known index | Loop iteration |

### 6.5 Memory Layout of RepeatedGroup

```cpp
// Each repetition uses Group::size() bytes
struct IoBoardLayout {
    // 8 consumer configs at offset 128, each ConsumerConfig::size() bytes
    ConsumerConfig consumer[8];  // offset 128 + (0..7) * ConsumerConfig::size()
    
    // 8 producer configs after consumers
    ProducerConfig producer[8];  // offset 128 + (8 * ConsumerConfig::size()) + (0..7) * ProducerConfig::size()
};

// Total size: 128 + (8 * ConsumerConfig::size()) + (8 * ProducerConfig::size())
const size_t CONFIG_FILE_SIZE = cfg.seg().end_offset();
```

### 6.6 Size Queries

```cpp
// Get number of repetitions
constexpr unsigned num_items = config.consumers().num_repeats();  // = NUM_OUTPUTS

// Get total size of repeated group
constexpr unsigned total_size = config.consumers().size();  // = NUM_OUTPUTS * ConsumerConfig::size()

// Get absolute end offset
constexpr unsigned end_offset = config.consumers().end_offset();
```

---

## 7. Nested Groups and Complex Structures

### 7.1 Group Nesting

Groups can be nested multiple levels deep:

```cpp
// Inner group (GPIO configuration)
CDI_GROUP(GPIOConfig);
CDI_GROUP_ENTRY(pin, Uint8ConfigEntry, Default(0), Min(0), Max(39));
CDI_GROUP_ENTRY(polarity, Uint8ConfigEntry, Default(0), Min(0), Max(1));
CDI_GROUP_END();

// Outer group (Output configuration)
CDI_GROUP(OutputConfig);
CDI_GROUP_ENTRY(description, StringConfigEntry<16>);
CDI_GROUP_ENTRY(gpio, GPIOConfig, Name("GPIO"));  // Nested group
CDI_GROUP_ENTRY(event_on, EventConfigEntry);
CDI_GROUP_ENTRY(event_off, EventConfigEntry);
CDI_GROUP_END();

// Array of outputs
using AllOutputs = RepeatedGroup<OutputConfig, 8>;

// Top-level segment
CDI_GROUP(IoBoardSegment, Segment(MemoryConfigDefs::SPACE_CONFIG), Offset(128));
CDI_GROUP_ENTRY(outputs, AllOutputs, Name("Outputs"), RepName("Output"));
CDI_GROUP_END();
```

### 7.2 Accessing Nested Fields

```cpp
// Compile-time nested access
uint8_t pin = cfg.seg().outputs().entry<0>().gpio().pin().read(fd);

// Runtime nested access
for (unsigned i = 0; i < 8; ++i) {
    auto output = cfg.seg().outputs().entry(i);
    uint8_t pin = output.gpio().pin().read(fd);
    uint8_t polarity = output.gpio().polarity().read(fd);
    uint64_t event_on = output.event_on().read(fd);
    uint64_t event_off = output.event_off().read(fd);
}
```

### 7.3 Size Calculation with Nesting

Offsets are automatically calculated at compile-time:

```cpp
// Each OutputConfig contains:
//   - description: StringConfigEntry<16> = 16 bytes
//   - gpio: GPIOConfig = 2 bytes (pin + polarity)
//   - event_on: EventConfigEntry = 8 bytes
//   - event_off: EventConfigEntry = 8 bytes
// Total per output: 16 + 2 + 8 + 8 = 34 bytes

// AllOutputs = RepeatedGroup<OutputConfig, 8>
// Total size: 8 * 34 = 272 bytes

const size_t OUTPUTS_SIZE = cfg.seg().outputs().size();  // = 272
```

---

## 8. Empty Groups and Reserved Space

### 8.1 EmptyGroup

Reserve space without defining entries:

```cpp
CDI_GROUP_ENTRY(reserved_space, EmptyGroup<16>);  // Reserve 16 bytes
```

### 8.2 Use Cases

1. **Compatibility:** Preserve space for future firmware additions
2. **Alignment:** Pad to specific byte boundaries
3. **Placeholder:** Mark space before moving to next segment

### 8.3 Memory Layout

```cpp
CDI_GROUP(MyConfig, Segment(MemoryConfigDefs::SPACE_CONFIG), Offset(128));
CDI_GROUP_ENTRY(active_mode, Uint8ConfigEntry, Default(1));      // offset 128, 1 byte
CDI_GROUP_ENTRY(reserved_for_future_1, EmptyGroup<7>);           // offset 129, 7 bytes (total 8)
CDI_GROUP_ENTRY(event_id, EventConfigEntry);                     // offset 136, 8 bytes
CDI_GROUP_ENTRY(reserved_for_future_2, EmptyGroup<16>);          // offset 144, 16 bytes
CDI_GROUP_END();

// Total: 1 + 7 + 8 + 16 = 32 bytes used
```

---

# PART 3: MACRO REFERENCE

## 9. CDI Definition Macros

### 9.1 Core Macros

| Macro | Purpose | Example |
|-------|---------|---------|
| `CDI_GROUP(Name, Options...)` | Start a configuration group | `CDI_GROUP(MyConfig, Name("Settings"))` |
| `CDI_GROUP_ENTRY(name, Type, Options...)` | Add entry to group | `CDI_GROUP_ENTRY(mode, Uint8ConfigEntry, Default(1))` |
| `CDI_GROUP_END()` | Finish group definition | `CDI_GROUP_END()` |
| `MainCdi()` | Mark as main CDI root | `CDI_GROUP(ConfigDef, MainCdi())` |
| `Segment(id)` | Specify memory space | `Segment(MemoryConfigDefs::SPACE_CONFIG)` |
| `Offset(bytes)` | Set starting byte offset | `Offset(128)` |

### 9.2 Configuration Options for CDI_GROUP

| Option | Type | Purpose | Example |
|--------|------|---------|---------|
| `Name(str)` | const char* | Display name in UI | `Name("Settings")` |
| `Description(str)` | const char* | Detailed description | `Description("Node settings")` |
| `Segment(id)` | int | Memory space | `Segment(0)` for config space |
| `Offset(bytes)` | int | Byte offset in memory space | `Offset(128)` |
| `RepName(str)` | const char* | Name template for repeated entries | `RepName("Output")` |
| `FixedSize(bytes)` | int | Force group to fixed size | `FixedSize(256)` |
| `Hidden(true)` | bool | Don't render in CDI | `Hidden(true)` |

**File Location:** OpenMRNLite/src/openlcb/ConfigRepresentation.hxx (lines 100-130)

### 9.3 Configuration Options for CDI_GROUP_ENTRY

| Option | Type | Purpose | Example |
|--------|------|---------|---------|
| `Name(str)` | const char* | Display name | `Name("Blink Interval")` |
| `Description(str)` | const char* | Detailed description | `Description("Milliseconds between blinks")` |
| `Default(value)` | int | Factory reset value | `Default(1000)` |
| `Min(value)` | int | Minimum acceptable value | `Min(100)` |
| `Max(value)` | int | Maximum acceptable value | `Max(30000)` |
| `MapValues(xml)` | const char* | Multi-choice options | `MapValues(MODE_MAP)` |
| `Hints(str)` | const char* | UI rendering hints | `Hints("spinbox")` |
| `SkipInit(flag)` | int | Skip initialization callback | `SkipInit(0)` |

**File Locations:**
- OpenMRNLite/src/openlcb/ConfigRepresentation.hxx (lines 100-130)
- OpenMRNLite/src/openlcb/ConfigRenderer.hxx (lines 40-120)

---

## 10. Runtime Configuration Macros

### 10.1 Read Macros

| Macro | Purpose | Example |
|-------|---------|---------|
| `value.read(fd)` | Read value from config file | `uint16_t v = cfg.seg().interval().read(fd)` |
| `CDI_READ_TRIMMED(path, fd)` | Read with min/max clamping | `uint16_t v = CDI_READ_TRIMMED(cfg.seg().port, fd)` |
| `CDI_READ_TRIM_DEFAULT(path, fd)` | Read with default fallback | `uint16_t v = CDI_READ_TRIM_DEFAULT(cfg.seg().port, fd)` |

### 10.2 Write Macros

| Macro | Purpose | Example |
|-------|---------|---------|
| `value.write(fd, data)` | Write value to config file | `cfg.seg().interval().write(fd, 2000)` |
| `CDI_FACTORY_RESET(path)` | Reset to default value | `CDI_FACTORY_RESET(cfg.seg().mode)` |

### 10.3 Macro Details

#### CDI_READ_TRIMMED
```cpp
// Clamps value to [Min, Max] range
// If out of range, overwrites file with clamped value
uint16_t port = CDI_READ_TRIMMED(cfg.seg().port, fd);
// If file contains 99999, will clamp to Max and rewrite file
```

#### CDI_READ_TRIM_DEFAULT
```cpp
// If value is outside [Min, Max], uses Default() instead
// Overwrites file with default value
uint16_t mode = CDI_READ_TRIM_DEFAULT(cfg.seg().mode, fd);
// If file contains invalid value, will use Default(1) and rewrite file
```

#### CDI_FACTORY_RESET
```cpp
// Write Default() value to file without reading
// Useful in factory_reset() handlers
CDI_FACTORY_RESET(cfg.seg().event_on);
// Writes the value specified in Default(...) macro
```

**File Location:** OpenMRNLite/src/openlcb/ConfigRepresentation.hxx (lines 323-360)

---

# PART 4: STRUCTURE AND ORGANIZATION

## 11. Configuration Structure Patterns

### 11.1 CDI_GROUP Macro Hierarchy

All configurations follow a hierarchical structure using CDI_GROUP macros:

```cpp
// Main CDI structure
CDI_GROUP(ConfigDef, MainCdi());
CDI_GROUP_ENTRY(ident, Identification);       // Standard node identification
CDI_GROUP_ENTRY(acdi, Acdi);                  // Standard node info
CDI_GROUP_ENTRY(userinfo, UserInfoSegment);   // User name/description
CDI_GROUP_ENTRY(seg, MySettingsSegment);      // Custom settings
CDI_GROUP_END();

// Custom settings segment
CDI_GROUP(MySettingsSegment,
    Segment(MemoryConfigDefs::SPACE_CONFIG),  // Memory space
    Offset(128));                              // Byte offset in space
CDI_GROUP_ENTRY(internal_config, InternalConfigData);
CDI_GROUP_ENTRY(mode, Uint8ConfigEntry, Default(1), MapValues(MODE_MAP));
CDI_GROUP_END();
```

### 11.2 Standard vs Custom Segments

**Standard Segments:**
- `Identification` - Node type, manufacturer info
- `Acdi` - ACDI (Accessory Configuration Description Information)
- `UserInfoSegment` - User-editable name and description

**Custom Segments:**
- Define your own CDI_GROUP with `Segment(MemoryConfigDefs::SPACE_CONFIG)` for application-specific configuration

### 11.3 Memory Space Definition

```cpp
enum ConfigSpace {
    SPACE_CONFIG = 0,       // Main configuration space
    SPACE_ACDI_USR = 251,   // User ACDI space
    SPACE_ACDI_MFG = 252,   // Manufacturer ACDI space
    SPACE_CDI = 255         // Configuration Description Information (XML)
};

// Use in segment definition
CDI_GROUP(MySettings, Segment(MemoryConfigDefs::SPACE_CONFIG), Offset(128));
// ... entries ...
CDI_GROUP_END();
```

---

## 12. Complete Working Example

### 12.1 async_blink ESP32 Configuration

**File:** test/async_blink_esp32/include/config.h

```cpp
#include "openlcb/ConfigRepresentation.hxx"
#include "openlcb/MemoryConfig.hxx"

namespace openlcb {

// SNIP (Simple Node Information Protocol) static data - read-only
extern const SimpleNodeStaticValues SNIP_STATIC_DATA = {
    4,               // Version
    "OpenMRN",       // Manufacturer
    "async_blink",   // Model
    "ESP32",         // Hardware version
    "1.00"           // Software version
};

// SNIP dynamic data - user-editable
static const char SNIP_NODE_NAME[] = "async_blink";
static const char SNIP_NODE_DESC[] = "ESP32 Blink demo";

// Configuration version for migration
static constexpr uint16_t CANONICAL_VERSION = 0x0001;

// Custom settings segment
CDI_GROUP(AsyncBlinkSegment,
    Segment(MemoryConfigDefs::SPACE_CONFIG),  // Store in config space
    Offset(128));                              // At byte offset 128
CDI_GROUP_ENTRY(internal_config, InternalConfigData);
CDI_GROUP_ENTRY(blink_interval, Uint16ConfigEntry,
                Default(1000),
                Min(100),
                Max(30000),
                Name("Blink Interval"),
                Description("Milliseconds between alternating events (100-30000)"));
CDI_GROUP_END();

// Main configuration structure
CDI_GROUP(ConfigDef, MainCdi());
CDI_GROUP_ENTRY(ident, Identification);
CDI_GROUP_ENTRY(acdi, Acdi);
CDI_GROUP_ENTRY(userinfo, UserInfoSegment, Name("User Info"));
CDI_GROUP_ENTRY(seg, AsyncBlinkSegment, Name("Settings"));
CDI_GROUP_END();

} // namespace openlcb
```

### 12.2 ConfigUpdateListener Implementation

**File:** test/async_blink_esp32/src/main.cpp

```cpp
// Create global config structure
static constexpr openlcb::ConfigDef cfg(0);

// Cached configuration value
unsigned long event_interval = 1000;

// Factory reset handler
class FactoryResetHelper : public DefaultConfigUpdateListener {
public:
    UpdateAction apply_configuration(int fd, bool initial_load,
                                     BarrierNotifiable *done) OVERRIDE {
        AutoNotify n(done);
        
        // Read the blink interval from config file and update global variable
        event_interval = cfg.seg().blink_interval().read(fd);
        Serial.printf("Configuration updated: blink_interval = %lu ms\n", event_interval);
        
        return UPDATED;
    }

    void factory_reset(int fd) override {
        // Initialize SNIP dynamic data on first boot
        cfg.userinfo().name().write(fd, openlcb::SNIP_NODE_NAME);
        cfg.userinfo().description().write(fd, openlcb::SNIP_NODE_DESC);
        
        // Initialize application settings with defaults
        cfg.seg().blink_interval().write(fd, 1000);  // Default 1 second
        Serial.println("Factory reset: wrote default blink_interval = 1000 ms");
    }
} factory_reset_helper;
```

---

## 13. Summary

### Basic Types
- **Integer:** Uint8/16/32/64, Int8/16/32/64 with Min/Max/Default constraints
- **Boolean:** Uint8ConfigEntry with MapValues XML
- **Multi-Choice:** Uint8/16ConfigEntry with MapValues XML
- **Event ID:** EventConfigEntry (specialized Uint64ConfigEntry)
- **String:** StringConfigEntry<SIZE> for fixed-size strings

### Advanced Constructs
- **RepeatedGroup<T, N>:** Arrays of configuration groups
- **Nested Groups:** Groups containing other groups for complex structures
- **EmptyGroup<N>:** Reserved space for future expansion

### Key Macros
- **Definition:** CDI_GROUP(), CDI_GROUP_ENTRY(), Name(), Description(), Default(), Min(), Max(), MapValues()
- **Runtime:** value.read(fd), value.write(fd, data), CDI_READ_TRIMMED(), CDI_FACTORY_RESET()

### Integration
- **ConfigUpdateListener:** Implement for monitoring configuration changes
- **factory_reset():** Initialize defaults on first boot
- **apply_configuration():** Called on boot and when JMRI changes config
- **File Descriptor:** Passed to all listener methods for read/write access

---

**Document Generated:** December 25, 2025  
**Research Scope:** OpenMRNLite classes, macros, and patterns  
**Status:** Complete
