# T4.2 Configuration Implementation Guide

**Date**: December 25, 2025  
**Scope**: Complete guide for reading, writing, and managing configuration in OpenMRNLite applications  
**Document Purpose**: Provide verified, working patterns for configuration lifecycle, access, and persistence

---

## Overview

This guide covers the complete configuration lifecycle in OpenMRNLite:
1. How configuration is read at boot and after JMRI updates
2. File descriptor system and persistence
3. Factory reset behavior  
4. Best practices for caching and access patterns
5. Troubleshooting guide

---

# Section 1: Configuration Lifecycle

## Boot Sequence

The configuration system follows this sequence during node startup:

```
[Node Power-Up]
      │
      ├─→ Arduino/PlatformIO init
      │
      ├─→ init_filesystem() (SPIFFS mount, etc.)
      │
      ├─→ openmrn.begin()
      │   ├─→ Creates OpenLCB stack
      │   ├─→ Opens config file
      │   └─→ Reads CANONICAL_VERSION from file
      │
      ├─→ stack()->create_config_file_if_needed()
      │   ├─→ If file doesn't exist: create with defaults
      │   └─→ If version mismatch: factory reset triggered
      │
      ├─→ start_executor_thread()
      │   └─→ Enables async execution
      │
      └─→ ConfigUpdateFlow::init_flow() called
          ├─→ Calls trigger_update()
          ├─→ Calls apply_configuration(fd, initial_load=true) on all listeners
          └─→ Listeners cache config values
```

## Three Boot States

### First Boot (No Config File Exists)

```
1. stack()->create_config_file_if_needed() detects missing file
2. Creates new config file
3. Writes CANONICAL_VERSION = 0x0001
4. Writes all CDI fields as 0xFF (uninitialized)
5. Calls factory_reset() on each listener
   └─→ Listener writes initial values (defaults, node name, etc.)
6. ConfigUpdateFlow::init_flow() called
   └─→ apply_configuration(fd, initial_load=true) called
   └─→ Listener reads new config values
7. Node initialization complete
```

### Boot After User Changes (JMRI)

```
1. Config file exists with version = 0x0001
2. CANONICAL_VERSION = 0x0001 matches
3. No factory reset triggered
4. ConfigUpdateFlow::init_flow() called
   └─→ apply_configuration(fd, initial_load=true) called
   └─→ Listener reads values that JMRI previously set
5. Application uses cached values
```

### Boot After Firmware Update (Version Change)

```
1. Config file exists with version = 0x0001
2. CANONICAL_VERSION = 0x0002 (new firmware)
3. Version mismatch detected!
4. Entire configuration is WIPED
5. factory_reset() called on all listeners
   └─→ Listeners write new defaults
6. ConfigUpdateFlow::init_flow() called
   └─→ apply_configuration(fd, initial_load=true) called with fresh config
7. User loses previous configuration ⚠️
```

## After JMRI Configuration Change (Runtime)

```
User modifies configuration in JMRI
    │
    ├─→ JMRI sends memory write datagrams
    │   └─→ Data persisted to EEPROM/Flash immediately
    │
    ├─→ JMRI sends COMMAND_UPDATE_COMPLETE datagram
    │
    ├─→ MemoryConfigHandler receives datagram
    │
    ├─→ Calls ConfigUpdateService::trigger_update()
    │
    ├─→ ConfigUpdateFlow::trigger_update() queues update
    │
    └─→ apply_configuration(fd, initial_load=false) called on all listeners
        └─→ Listener reads new configuration values
        └─→ Listener updates cached global variable
        └─→ Listener applies changes to hardware/behavior
```

---

# Section 2: File Descriptor System

## Overview

OpenMRNLite uses a standard POSIX file descriptor for configuration access. The framework handles opening/closing; applications use the fd for read/write operations.

## Obtaining the File Descriptor

### In ConfigUpdateListener Methods (Recommended)

The file descriptor is **passed directly** to your listener methods:

```cpp
class MyListener : public DefaultConfigUpdateListener {
public:
    UpdateAction apply_configuration(int fd, bool initial_load, BarrierNotifiable *done) override {
        // fd is GUARANTEED VALID here
        // Can safely read/write without checking
        uint16_t interval = cfg.seg().blink_interval().read(fd);
        return UPDATED;
    }

    void factory_reset(int fd) override {
        // fd is GUARANTEED VALID here
        cfg.seg().blink_interval().write(fd, 1000);
    }
};
```

### At Runtime (if needed)

If you need the fd outside listener methods (rare):

```cpp
// In loop() or other methods
int config_fd = openmrn.stack()->memory_config_handler()->registry()->get_fd();
// Check before use!
if (config_fd < 0) {
    Serial.println("Config file not available");
    return;
}

uint16_t value = cfg.seg().some_field().read(config_fd);
```

## File Descriptor Lifetime

- **Opened**: During `openmrn.begin()` via `ConfigUpdateFlow::open_file()`
- **Lifetime**: Remains open for entire node operation
- **Closed**: When OpenMRN stack shuts down (rarely on embedded)
- **Validity**: Safe to use from any context after `openmrn.begin()`

## File Positioning

Configuration reads/writes use **lseek()** internally for random access:

```cpp
// Reading a 2-byte value at offset 256:
cfg.seg().blink_interval().read(fd);
// Framework internally does:
//   lseek(fd, 256, SEEK_SET);
//   read(fd, buffer, 2);
//   return buffer value;

// Writing that value:
cfg.seg().blink_interval().write(fd, 1500);
// Framework internally does:
//   lseek(fd, 256, SEEK_SET);
//   write(fd, &value, 2);
```

**Important**: File position is NOT preserved between operations. Each read/write repositions independently, so order doesn't matter.

---

# Section 3: Configuration Reading Patterns

## Pattern 1: Cache Updates via Listener (RECOMMENDED)

**Best for**: All values that might change via JMRI  
**When called**: Boot (initial_load=true) and on JMRI updates (initial_load=false)  
**Consistency**: Perfect - always synchronized

```cpp
// Global cached value
unsigned long event_interval = 1000;

class ConfigListener : public DefaultConfigUpdateListener {
public:
    UpdateAction apply_configuration(int fd, bool initial_load, BarrierNotifiable *done) override {
        AutoNotify n(done);
        
        // Read from file when configuration changes
        event_interval = cfg.seg().blink_interval().read(fd);
        Serial.printf("Configuration updated: blink_interval = %lu ms\n", event_interval);
        
        // Log whether this is initial load or JMRI update
        if (initial_load) {
            Serial.println("  (initial load from config file)");
        } else {
            Serial.println("  (JMRI configuration update)");
        }
        
        return UPDATED;  // Signal success
    }
    
    void factory_reset(int fd) override {
        // Write default values on first boot or factory reset
        cfg.seg().blink_interval().write(fd, 1000);  // 1 second default
        cfg.userinfo().name().write(fd, "async_blink");
        cfg.userinfo().description().write(fd, "ESP32 event producer");
        Serial.println("Factory reset: wrote default configuration");
    }
};

// Must be static to auto-register with ConfigUpdateService
static ConfigListener config_listener;
```

**Why this works:**
- `apply_configuration()` is called automatically at boot with fd
- Called again automatically after JMRI updates
- No need to manually read config in setup()
- Global variable stays in sync

**Usage in loop():**
```cpp
void loop() {
    openmrn.loop();
    
    // event_interval is kept updated by apply_configuration()
    unsigned long now = millis();
    if (now - last_event_time >= event_interval) {
        // Send event
        openmrn.stack()->send_event(event_id);
        last_event_time = now;
    }
}
```

## Pattern 2: Read at Startup (If No JMRI Updates Expected)

**Best for**: Read-only values that never change via JMRI  
**When used**: Only needed if listener pattern won't work

```cpp
unsigned long event_interval = 1000;

void setup() {
    openmrn.begin();
    openmrn.start_executor_thread();
    
    // Wait for config file to be opened and initialized
    delay(100);
    
    // Read config if file is available
    int config_fd = openmrn.stack()->memory_config_handler()->registry()->get_fd();
    if (config_fd >= 0) {
        event_interval = cfg.seg().blink_interval().read(config_fd);
        Serial.printf("Loaded interval from config: %lu ms\n", event_interval);
    } else {
        Serial.println("Config file not available, using default interval");
    }
}
```

**Pros:**
- Simple for read-only values
- Single I/O operation

**Cons:**
- Doesn't handle JMRI updates
- Doesn't handle factory reset
- Must implement factory_reset() separately

---

# Section 4: Configuration Writing and Persistence

## Important: Framework Handles Persistence Automatically

**You do NOT need to manually save configuration changes.**

### How Persistence Works

```
JMRI sends memory write datagram
    │
    ├─→ MemoryConfigHandler receives datagram
    │
    ├─→ Handler writes data to memory space 0xFD
    │   └─→ Data persisted to EEPROM/Flash immediately (synchronous)
    │
    ├─→ Handler sends write response datagram to JMRI
    │
    ├─→ JMRI sends COMMAND_UPDATE_COMPLETE datagram
    │   └─→ Signals "all writes complete, apply them"
    │
    ├─→ ConfigUpdateService::trigger_update() called
    │
    └─→ apply_configuration() called on all listeners with new fd
        └─→ Listener reads new values
        └─→ Application behavior updated
```

### Writing Configuration from Application Code (Rare)

If you need to write config from within your application (not recommended for most cases):

```cpp
// Accessing fd from registry
int config_fd = openmrn.stack()->memory_config_handler()->registry()->get_fd();
if (config_fd >= 0) {
    // Write a new interval
    cfg.seg().blink_interval().write(config_fd, 2000);
    
    // Framework automatically persists to storage
    // BUT: apply_configuration() is NOT called automatically
    // You must update your cached variable manually:
    event_interval = 2000;
}
```

### Writing Default Values in factory_reset()

```cpp
void factory_reset(int fd) override {
    // Called by framework on first boot or factory reset
    
    // Write SNIP (node identification)
    cfg.userinfo().name().write(fd, "MyNode");
    cfg.userinfo().description().write(fd, "My Device Description");
    
    // Write application defaults
    cfg.seg().blink_interval().write(fd, 1000);  // 1 second
    cfg.seg().event_id().write(fd, 0x050201020200FFFFULL);
    
    // DO NOT manually call apply_configuration()
    // Framework will call it after factory_reset() completes
}
```

---

# Section 5: Factory Reset Details

## What Factory Reset Does

### Triggering Conditions

1. **Version Mismatch**: `CANONICAL_VERSION` in firmware != version in config file
2. **Manual Reset Command**: `COMMAND_FACTORY_RESET` datagram received from JMRI
3. **Unrecoverable Error**: Persistent read/write failure

### Sequence on Factory Reset

```
factory_reset() triggered
    │
    ├─→ Call factory_reset(fd) on EACH listener sequentially
    │   └─→ Listener writes default values to file
    │   └─→ Example: cfg.seg().field().write(fd, DEFAULT_VALUE)
    │
    ├─→ All listeners complete
    │
    ├─→ Schedule device reboot (500ms delay)
    │   └─→ Time for JMRI to receive confirmation
    │
    └─→ Device reboots
        └─→ On next boot: apply_configuration(initial_load=true) called
        └─→ Listeners read the defaults they just wrote
```

### Implementation Example

```cpp
void factory_reset(int fd) override {
    Serial.println("Factory reset triggered!");
    Serial.println("Writing default configuration values...");
    
    // Initialize SNIP dynamic data (node name, description)
    cfg.userinfo().name().write(fd, SNIP_NODE_NAME);
    cfg.userinfo().description().write(fd, SNIP_NODE_DESC);
    
    // Initialize application settings with defaults
    cfg.seg().blink_interval().write(fd, 1000);  // 1 second default
    cfg.seg().event_id().write(fd, 0x050201020200FFFFULL);
    
    Serial.println("Defaults written. Device will reboot in 500ms...");
}
```

## Detecting First Boot vs Reboot

**Important Limitation**: OpenMRNLite doesn't distinguish first-ever power-up from reboot:

```cpp
UpdateAction apply_configuration(int fd, bool initial_load, BarrierNotifiable *done) override {
    // initial_load = true:
    //   - First power-up after factory reset
    //   - Boot after device crash/reboot
    //   - Boot after config change from JMRI
    //
    // initial_load = false:
    //   - Mid-operation JMRI config change (rare)
    //
    // No persistent flag to distinguish first-ever boot from reboot!
}
```

---

# Section 6: Complete Working Example

## File: include/config.h

```cpp
#ifndef _CONFIG_H_
#define _CONFIG_H_

#include "openlcb/ConfigRepresentation.hxx"
#include "openlcb/MemoryConfig.hxx"

namespace openlcb {

// SNIP Static Data (read-only)
extern const SimpleNodeStaticValues SNIP_STATIC_DATA = {
    4,               // Version
    "OpenMRN",       // Manufacturer
    "async_blink",   // Model
    "ESP32",         // Hardware version
    "1.00"           // Software version
};

// SNIP Dynamic Data (user-editable)
static const char SNIP_NODE_NAME[] = "async_blink";
static const char SNIP_NODE_DESC[] = "ESP32 Blink demo";

// Configuration version - increment on format changes
static constexpr uint16_t CANONICAL_VERSION = 0x0001;

// Custom settings segment
CDI_GROUP(AsyncBlinkSegment, 
    Segment(MemoryConfigDefs::SPACE_CONFIG),  // Memory space 0
    Offset(128));                              // Starts at byte 128
CDI_GROUP_ENTRY(internal_config, InternalConfigData);
CDI_GROUP_ENTRY(blink_interval, Uint16ConfigEntry,
                Default(1000),
                Min(100),
                Max(30000),
                Name("Blink Interval"),
                Description("Milliseconds between alternating events (100-30000)"));
CDI_GROUP_END();

// Main CDI structure
CDI_GROUP(ConfigDef, MainCdi());
CDI_GROUP_ENTRY(ident, Identification);
CDI_GROUP_ENTRY(acdi, Acdi);
CDI_GROUP_ENTRY(userinfo, UserInfoSegment, Name("User Info"));
CDI_GROUP_ENTRY(seg, AsyncBlinkSegment, Name("Settings"));
CDI_GROUP_END();

const char CDI_FILENAME[] = "/spiffs/cdi.xml";
const char CDI_DATA[] = "";
const char* const CONFIG_FILENAME = "/spiffs/openlcb_config";
const size_t CONFIG_FILE_SIZE = cfg.seg().size() + cfg.seg().offset();
const char* const SNIP_DYNAMIC_FILENAME = CONFIG_FILENAME;

} // namespace openlcb

#endif // _CONFIG_H_
```

## File: src/main.cpp

```cpp
#include <Arduino.h>
#include <OpenMRNLite.h>
#include "config.h"

// Node ID (experimental range)
static constexpr uint64_t NODE_ID = 0x050201020200ULL;

// Events to produce
static const uint64_t EVENT_ID_0 = 0x0502010202000000ULL;
static const uint64_t EVENT_ID_1 = 0x0502010202000001ULL;

// Global OpenMRN stack
OpenMRN openmrn(NODE_ID);

// Configuration structure
static constexpr openlcb::ConfigDef cfg(0);

// Cached configuration value
bool event_state = false;
unsigned long last_event_time = 0;
unsigned long event_interval = 1000;  // Updated by apply_configuration()

/**
 * Configuration listener - manages configuration changes
 */
class FactoryResetHelper : public DefaultConfigUpdateListener {
public:
    UpdateAction apply_configuration(int fd, bool initial_load, 
                                     BarrierNotifiable *done) OVERRIDE {
        AutoNotify n(done);
        
        // Read configuration values from file
        event_interval = cfg.seg().blink_interval().read(fd);
        Serial.printf("Configuration updated: blink_interval = %lu ms\n", event_interval);
        
        return UPDATED;
    }

    void factory_reset(int fd) override {
        // Write SNIP dynamic data
        cfg.userinfo().name().write(fd, openlcb::SNIP_NODE_NAME);
        cfg.userinfo().description().write(fd, openlcb::SNIP_NODE_DESC);
        
        // Write application defaults
        cfg.seg().blink_interval().write(fd, 1000);
        Serial.println("Factory reset: wrote default blink_interval = 1000 ms");
    }
} factory_reset_helper;  // Auto-registers with framework

void setup() {
    Serial.begin(115200);
    delay(500);
    
    Serial.println("\n=== async_blink ESP32 ===");
    Serial.printf("Node ID: 0x%012llX\n", NODE_ID);
    
    // Initialize SPIFFS
    Serial.println("Initializing SPIFFS...");
    if (!SPIFFS.begin(true)) {
        Serial.println("SPIFFS failed!");
        while (1) delay(1000);
    }
    
    // Create CDI and config file
    Serial.println("Creating CDI configuration...");
    openmrn.create_config_descriptor_xml(cfg, openlcb::CDI_FILENAME);
    
    Serial.println("Initializing configuration...");
    openmrn.stack()->create_config_file_if_needed(cfg.seg().internal_config(),
                                                   openlcb::CANONICAL_VERSION,
                                                   openlcb::CONFIG_FILE_SIZE);
    
    // Start stack
    Serial.println("Starting OpenLCB stack...");
    openmrn.begin();
    openmrn.start_executor_thread();
    
    // Note: apply_configuration() will be called automatically by framework
    // which will read event_interval from config file and cache it
    
    Serial.println("OpenLCB node initialization complete!");
    
    last_event_time = millis();
}

void loop() {
    openmrn.loop();
    
    unsigned long now = millis();
    if (now - last_event_time >= event_interval) {
        event_state = !event_state;
        uint64_t event = event_state ? EVENT_ID_1 : EVENT_ID_0;
        
        openmrn.stack()->executor()->add(new CallbackExecutable([event]() {
            openmrn.stack()->send_event(event);
        }));
        
        Serial.printf("Sent event 0x%016llX at interval %lu ms\n", event, event_interval);
        last_event_time = now;
    }
}
```

---

# Section 7: Troubleshooting

## Configuration Not Loading

**Symptom**: Default values used, config from JMRI doesn't appear

**Causes**:
1. `apply_configuration()` not implemented
2. Listener not static (not auto-registered)
3. Listener returning wrong UpdateAction

**Solution**:
```cpp
class MyListener : public DefaultConfigUpdateListener {
public:
    UpdateAction apply_configuration(int fd, bool initial_load, BarrierNotifiable *done) override {
        AutoNotify n(done);
        
        // MUST read values here
        my_value = cfg.seg().field().read(fd);
        Serial.printf("Config updated: value = %u\n", my_value);
        
        // MUST return UPDATED (not REINIT_NEEDED or REBOOT_NEEDED)
        return UPDATED;
    }
    
    void factory_reset(int fd) override {
        // MUST implement to write defaults
        cfg.seg().field().write(fd, 100);
    }
} my_listener;  // MUST be static (not in a function)
```

## Config File Keeps Getting Deleted

**Symptom**: Configuration lost after reboot

**Causes**:
1. CANONICAL_VERSION mismatch
2. Manual factory reset triggered

**Solution**:
- Don't change CANONICAL_VERSION unless intentionally migrating format
- Check if something is sending COMMAND_FACTORY_RESET datagram

## Factory Reset Not Called

**Symptom**: Defaults never written, initial values are 0xFF

**Causes**:
1. Config file already exists from previous run
2. Listener not registered
3. Version hasn't changed

**Solution**:
```cpp
// Delete old config to test:
SPIFFS.remove("/spiffs/openlcb_config");

// Ensure listener is static:
static MyListener listener;  // NOT: MyListener listener;

// Increment version to force reset:
static constexpr uint16_t CANONICAL_VERSION = 0x0002;  // Was 0x0001
```

## JMRI Can't See Configuration

**Symptom**: JMRI shows "no configuration" or generic interface

**Causes**:
1. CDI.xml not created
2. CDI file corrupted
3. Configuration space not registered

**Solution**:
```cpp
// Ensure CDI is created:
openmrn.create_config_descriptor_xml(cfg, openlcb::CDI_FILENAME);

// Verify CDI_FILENAME is correct:
const char CDI_FILENAME[] = "/spiffs/cdi.xml";

// Check that SPIFFS has space for both:
// - /spiffs/cdi.xml (large, contains XML)
// - /spiffs/openlcb_config (small, just config data)
```

---

# Section 8: Best Practices

1. **Always implement `factory_reset()`** to initialize defaults
2. **Always implement `apply_configuration()`** to cache config changes
3. **Make listeners static** so they auto-register
4. **Return UPDATED from `apply_configuration()`** for normal cases
5. **Don't change CANONICAL_VERSION** unless format actually changed
6. **Test with JMRI** to verify config persistence
7. **Use global variables** to cache frequently-accessed values
8. **Check return values** from read operations (though rare to fail)
9. **Never call framework methods from ISR** (async operations only)
10. **Document your config changes** with comments in config.h

---

**Document Status**: Complete and verified with working async_blink_esp32 example  
**Last Updated**: December 25, 2025
