# T4.2 Configuration Update Service - Research Summary

**Date**: December 24, 2025  
**Scope**: Researching OpenLCB standards alignment with OpenMRNLite implementation  
**Document Purpose**: Consolidate findings from both standards/TN research and source code analysis to establish a complete understanding of the Configuration Update Service architecture, workflow, current implementation status, and identified gaps.

---

## Section 1: OpenLCB Standards Overview

### Key Standards and Technical Notes (6 Documents)

The Configuration Update Service is defined across multiple OpenLCB standards and technical notes:

| Document | Title | Key Focus |
|----------|-------|-----------|
| **S-9.7.4.1** | Configuration Description Information (CDI) | Defines CDI XML schema for configurable parameters |
| **S-9.7.4.2** | Memory Configuration Protocol | Defines datagram-based memory read/write protocol |
| **S-9.7.4.3** | Simple Node Information Protocol (SNIP) | Defines node identification and manufacturer info |
| **TN-9.7.4.1** | CDI Technical Note | Implementation guidance for CDI |
| **TN-9.7.4.2** | Memory Configuration TN | Implementation guidance for memory config |
| **TN-9.7.4.3** | SNIP Technical Note | Implementation guidance for SNIP |

### Core Concepts

**Configuration Description Information (CDI)**
- XML-based definition of all configurable parameters for a node
- Accessible via memory space `0xFF` (read-only)
- Defines parameter types, defaults, ranges, and groups
- Enables configuration tools (like JMRI) to discover and configure any node

**Memory Configuration Protocol**
- Datagram-based protocol for reading/writing configuration memory
- Supports 256 unique memory address spaces (0x00-0xFF)
- Standard memory spaces:
  - `0xFF`: CDI (read-only) - the configuration description XML
  - `0xFE`: All Memory - special space providing access to device's entire memory
  - `0xFD`: Configuration - application-specific writable config data
  - `0xFC`, `0xFB`: Additional application-specific spaces
  - `0xF0`, `0xF1`, `0xF2`: Standard spaces in some implementations

**Simple Node Information Protocol (SNIP)**
- Static information about the node (manufacturer, model, version, etc.)
- Accessible via memory space addressing
- Provides human-readable device identification

### State Transitions

The OpenLCB initialization model defines two node states:

```
┌──────────────────┐
│   Initialized    │◄─────────────────┐
│  (Ready to       │                  │
│   operate)       │                  │
└────────┬─────────┘                  │
         │                            │
    Node resets or         Node sends "Update
    configuration           Complete" message
    is updated              (after configuration
         │                  changes are written)
         ▼                            │
┌──────────────────┐                  │
│  Uninitialized   │──────────────────┘
│  (Cannot accept  │
│   normal traffic)│
└──────────────────┘
```

**Key State Behaviors**:
- **Initialized**: Node can participate in OpenLCB protocol, handle events, respond to queries
- **Uninitialized**: Node cannot handle incoming events; signals initialization incompleteness to the network
- **Node Initialization Complete Message**: Required to transition from Uninitialized → Initialized after config changes

---

## Section 2: Configuration Update Workflow

### Discovery → Retrieval → Modification → Activation Flow

The complete configuration lifecycle follows this sequence:

#### Phase 1: Discovery
```
Configuration Tool (e.g., JMRI)
        │
        ├─→ Query node for supported address spaces
        ├─→ Read space 0xFF (CDI) to discover configurable parameters
        ├─→ Determine parameter structure and constraints
        └─→ Present UI to user
```

#### Phase 2: Retrieval
```
Configuration Tool reads current configuration
        │
        ├─→ Memory read requests to space 0xFD (or custom 0xFC, 0xFB)
        ├─→ Datagram transport protocol carries data
        └─→ Configuration data reconstructed from datagrams
```

#### Phase 3: Modification
```
User modifies parameters in configuration tool UI
        │
        └─→ Configuration Tool builds new complete configuration in memory
```

#### Phase 4: Activation
```
Configuration Tool writes modified configuration back to node
        │
        ├─→ Memory write requests to space 0xFD
        ├─→ Node persists data to EEPROM/Flash
        ├─→ Configuration Tool sends COMMAND_UPDATE_COMPLETE
        │
        ├─→ Node transitions to Uninitialized state
        ├─→ Node triggers ConfigUpdateFlow (trigger_update())
        ├─→ All ConfigUpdateListener instances apply new configuration
        ├─→ Node sends "Node Initialization Complete" message
        │
        └─→ Node transitions back to Initialized state
```

### Key Messages

**COMMAND_UPDATE_COMPLETE** (Memory Config Datagram)
- Sent by configuration tool after all writes complete
- Triggers `ConfigUpdateService::trigger_update()`
- Signals node to apply configuration changes

**Node Initialization Complete** (Addressed Message)
- Sent by node after applying configuration
- Indicates node is ready to process events again
- Required by OpenLCB standard after configuration changes

### State Machine Details

The node's lifecycle with respect to configuration:

```
[Startup]
    │
    ├─→ Open configuration file (EEPROM/Flash)
    ├─→ Check version matches firmware
    │   ├─ YES: Proceed to load
    │   └─ NO: Trigger factory_reset() on all listeners
    │
    ├─→ Call ConfigUpdateFlow::init_flow()
    │   ├─→ For each registered ConfigUpdateListener:
    │   │   └─→ Call listener->apply_configuration(fd, initial_load=true)
    │   └─→ Collect reboot/reinit requirements
    │
    ├─→ If REBOOT_NEEDED: Restart node
    ├─→ If REINIT_NEEDED: Start NodeInitializeFlow
    │
    └─→ Send "Node Initialization Complete" message
        └─→ Transition to Initialized state

[Running - User Modifies Config via JMRI]
    │
    ├─→ JMRI sends memory write datagrams
    ├─→ Node persists to EEPROM
    │
    ├─→ JMRI sends COMMAND_UPDATE_COMPLETE
    │   └─→ Triggers trigger_update()
    │
    ├─→ Call ConfigUpdateFlow::trigger_update()
    │   ├─→ Reset state machine
    │   ├─→ For each registered ConfigUpdateListener:
    │   │   └─→ Call listener->apply_configuration(fd, initial_load=false)
    │   └─→ Collect reboot/reinit requirements
    │
    ├─→ If REBOOT_NEEDED: Restart node
    ├─→ If REINIT_NEEDED: Start NodeInitializeFlow
    │
    └─→ Send "Node Initialization Complete" message
```

---

## Section 3: OpenMRNLite Current Implementation

### Architecture: Publish-Subscribe Pattern

OpenMRNLite implements configuration updates using a publish-subscribe (observer) pattern:

```cpp
// Core interface: ConfigUpdateService (publisher)
class ConfigUpdateService : public Singleton<ConfigUpdateService>
{
    virtual void register_update_listener(ConfigUpdateListener *listener) = 0;
    virtual void unregister_update_listener(ConfigUpdateListener *listener) = 0;
    virtual void trigger_update() = 0;
};

// Core interface: ConfigUpdateListener (subscriber)
class ConfigUpdateListener : public QMember
{
    enum UpdateAction { UPDATED, REINIT_NEEDED, REBOOT_NEEDED };
    
    virtual UpdateAction apply_configuration(
        int fd, bool initial_load, BarrierNotifiable *done) = 0;
    virtual void factory_reset(int fd) = 0;
};
```

### ConfigUpdateFlow: State Machine Implementation

`ConfigUpdateFlow.hxx` and `ConfigUpdateFlow.cxx` implement the state machine that coordinates all listeners:

**Key Responsibilities**:
- Maintains singleton instance of ConfigUpdateService
- Manages registration/unregistration of listeners
- Iterates through all listeners sequentially on `trigger_update()`
- Tracks reboot/reinit requirements across all listeners
- Handles final actions (reboot or node reinit)

**State Machine Flow**:
```cpp
trigger_update()
    ├─→ STATE(call_next_listener)
    │   └─→ Pop next listener from queue
    │       └─→ STATE(call_listener) - call apply_configuration()
    │           └─→ Wait for listener to complete (BarrierNotifiable)
    │               └─→ Loop back to call_next_listener
    │
    ├─→ STATE(do_initial_load) - when trigger_update() called first time
    │   └─→ Process pendingListeners (initial load before refresh)
    │
    └─→ STATE(apply_action) - when all listeners processed
        ├─→ If needsReboot_: call reboot()
        ├─→ If needsReInit_: create ReinitAllNodes flow
        └─→ Exit state machine
```

**File Descriptor Management**:
- Opened once via `openmrn.open_file()` before startup
- Same FD used for all listener `apply_configuration()` calls
- Listeners use `lseek()` to access their config data

### Current Listener Implementations (7 Known Types)

| Listener Class | File | Purpose |
|---|---|---|
| **ConfiguredConsumer** | ConfiguredConsumer.hxx | Simple GPIO-based event consumer with CDI config |
| **ConfiguredPulseConsumer** | ConfiguredPulseConsumer.hxx | Event consumer that pulses GPIO for fixed duration |
| **ConfiguredProducer** | ConfiguredProducer.hxx | Simple GPIO-based event producer with CDI config |
| **ServoConsumer** | ServoConsumer.hxx | PWM servo control with configurable event IDs |
| **MultiConfiguredConsumer** | MultiConfiguredConsumer.hxx | Multiple consumers in one listener |
| **MultiConfiguredPC** | MultiConfiguredPC.hxx | Multiple producer/consumer pairs |
| **Esp32WiFiManager** | Esp32WiFiManager.cpp | WiFi configuration listener |

### How trigger_update() Is Called

**Call Site**: `MemoryConfigHandler.cpp` line 727-729

```cpp
case MemoryConfigDefs::COMMAND_UPDATE_COMPLETE:
{
    Singleton<ConfigUpdateService>::instance()->trigger_update();
    break;
}
```

**Full Call Chain**:
1. Configuration Tool (JMRI) sends `COMMAND_UPDATE_COMPLETE` datagram
2. `MemoryConfigHandler` datagram handler receives message
3. Handler calls `trigger_update()` on ConfigUpdateService singleton
4. ConfigUpdateFlow state machine starts (or queues if already running)
5. Each registered listener's `apply_configuration()` is called sequentially
6. Final `apply_action` state handles reboot/reinit requirements

---

## Section 4: Standards Compliance Analysis

### What IS Implemented Correctly ✅

- **Basic publish-subscribe pattern** for configuration listeners
- **Sequential listener iteration** during configuration updates
- **Asynchronous state machine** for non-blocking listener calls (BarrierNotifiable pattern)
- **File descriptor passing** to listeners for configuration access
- **Return code support** (UPDATED, REINIT_NEEDED, REBOOT_NEEDED)
- **Factory reset triggering** when version mismatch detected
- **Memory space registration** for 0xF0, 0xF1, 0xF2 via MemoryConfigHandler
- **COMMAND_UPDATE_COMPLETE handling** that triggers configuration refresh
- **Node Initialization Complete message** generation after config changes

### What IS Partially Implemented ⚠️

- **Configuration file versioning**: Exists but triggers complete factory reset on mismatch (no field migration)
- **Asynchronous listener support**: Framework exists (ERROR_AGAIN + Notifiable pattern) but rarely used
- **Listener dependency ordering**: No support; listeners iterate in insertion order only
- **Configuration validation**: No pre-write validation; garbage data can be written to EEPROM
- **Listener status reporting**: No mechanism for listeners to report individual success/failure

### What IS NOT Implemented ❌

- **Persistent initialized flag**: No way to distinguish first boot from reboot
- **Field-level migration**: No mechanism to map old config format to new on version change
- **Automatic default application**: New fields get 0xFF (uninitialized) not defaults
- **Listener dependency ordering**: No dependency or priority system between listeners
- **Listener status aggregation**: No way to determine which listeners successfully applied config
- **Configuration rollback**: No checkpoint/rollback if listener fails partway through
- **Partial updates**: Configuration updates are all-or-nothing for each listener
- **Listener timeout handling**: No timeout if listener's `apply_configuration()` never completes
- **CDI_FACTORY_RESET macro safety**: Macro can cause compile errors if not used with accessor types

---

## Section 5: Identified Gaps and Issues

### Critical Gaps

#### Gap 1: No Persistent Initialized Flag
**Problem**: Nodes cannot distinguish between first boot and a reboot.
- On first boot after factory reset, listeners don't know if this is initial setup or recovery
- `initial_load` flag is only true at process startup, not after EEPROM factory reset
- Listeners cannot implement "first-time setup" logic that differs from "restore from backup"

**Impact**: Nodes that need special first-boot behavior (e.g., wizard modes, special initialization sequences) must use other mechanisms

**Standards Position**: OpenLCB expects nodes to track initialization state persistently

#### Gap 2: No Field Migration on Version Changes
**Problem**: When firmware version changes, entire configuration is wiped.
- Old config format is completely lost
- New fields appear as 0xFF (uninitialized)
- No mapping mechanism exists to preserve compatible fields
- Users lose all configuration when firmware updates

**Code Location**: `ConfigUpdateFlow.cxx` version check logic

**Impact**: 
- Users frustrated by lost configuration after updates
- No way to implement backward-compatible firmware changes
- Fields with defaults (0xFF) appear as garbage to listeners

**Example Scenario**:
```
v1.0 config: [EventID_1: 0x01.02.03.04.05.06.07.08] [Reserved: 0x00]
        ↓ firmware update
v2.0 config: [EventID_1: ???] [EventID_2: 0xFF] [Reserved: ???]
                             (lost, now uninitialized)
```

#### Gap 3: No Configuration Validation
**Problem**: Any data can be written to configuration memory.
- No validation of event IDs, node IDs, or other values
- Listeners receive garbage data and must handle/recover themselves
- No pre-write validation in memory config handler
- No rollback if listener fails due to bad data

**Impact**: 
- Corrupted configs can prevent node from functioning
- Hard to debug when user enters invalid config values
- No protection against malformed network datagrams

#### Gap 4: No Listener Dependency Ordering
**Problem**: Listeners execute in registration order, not dependency order.
- No way to specify "Listener A must run before Listener B"
- Some listeners may depend on others' state (e.g., GPIO allocation)
- Can cause initialization failures if run in wrong order

**Example**: 
```cpp
// These must run in specific order:
listener1.register(); // Allocates GPIO 5
listener2.register(); // Uses GPIO 5 from listener1
// But if listener2 registered first, listener1 might allocate GPIO 5 to different purpose
```

#### Gap 5: No Listener Status Reporting
**Problem**: ConfigUpdateFlow doesn't report individual listener success.
- Only aggregates REBOOT_NEEDED and REINIT_NEEDED flags
- No way to determine which listener failed
- Log messages must include listener name (hardcoded by each listener)

**Impact**:
- Hard to debug which listener caused config update failure
- No telemetry on configuration update success/failure
- Cannot report per-listener status back to configuration tool

#### Gap 6: No Asynchronous Config Support
**Problem**: Framework supports async via ERROR_AGAIN but almost never used.
- Most listeners implement blocking reads in `apply_configuration()`
- Async operations (like network fetches) not practical
- Notifiable wait pattern sufficient but complex to use correctly

**Impact**:
- Listeners that need to fetch configuration from cloud services must block
- Slow network operations stall entire config update
- Difficult to implement sophisticated listeners

### Standards Alignment Issues

| Issue | Standard Requirement | OpenMRNLite Implementation | Status |
|-------|----------------------|---------------------------|--------|
| **Initialization State** | Node tracks if uninitialized/initialized | Only process-level flag, not persistent | ⚠️ Partial |
| **Update Complete Signal** | Send Node Init Complete after config changes | Implemented via ReinitAllNodes | ✅ Complete |
| **Memory Spaces** | Support 0xFF (CDI), 0xFE (All), 0xFD (Config) | Supported via MemoryConfigHandler | ✅ Complete |
| **Datagram Protocol** | Memory read/write via datagrams | Implemented in DatagramHandler | ✅ Complete |
| **Version Tracking** | Version in config space | Implemented but resets on mismatch | ✅ Complete |
| **CDI XML Format** | CDI must be valid XML | Depends on application | Varies |
| **Factory Reset** | Support factory reset command | Implemented on version mismatch | ✅ Complete |

---

## Section 6: Memory Space Implementation Details

### Standard Memory Space Registration

OpenMRNLite's `MemoryConfigHandler` manages memory spaces for configuration access:

**Space 0xFF - Configuration Description (Read-Only)**
- Contains CDI XML data
- Automatically served by MemoryConfigHandler
- Defines all configurable parameters

**Space 0xFE - All Memory (Variable Access)**
- Provides access to full device memory
- Optional; designer-defined scope
- Implementation-specific

**Space 0xFD - Configuration (Writable)**
- Main configuration data space
- Application-specific structure
- Writes trigger memory config handler

**Space 0xF0, 0xF1, 0xF2 - Alternative Configuration Spaces**
- Some implementations use additional spaces:
  - 0xF0: Configuration (same as 0xFD)
  - 0xF1: Node Info (SNIP)
  - 0xF2: CDI Definition

### MemoryConfigHandler Role

`MemoryConfigHandler.cpp` implements the server side of memory config protocol:

```cpp
class MemoryConfigHandler : public DatagramHandlerDefault
{
    // Handles datagram messages for memory operations
    
    // Datagram commands:
    // - CMD_READ: Read from address space
    // - CMD_WRITE: Write to address space
    // - CMD_GET_CONFIG: Get space size/info
    // - CMD_UPDATE_COMPLETE: Trigger configuration refresh
    // - CMD_FACTORY_RESET: Trigger factory reset
};
```

**Write Flow for Space 0xF0 (Configuration)**:
```
Datagram Write Request (space=0xFD, addr=0, data=[...])
        ↓
MemoryConfigHandler.handle_datagram()
        ↓
Find registered MemorySpace for 0xFD
        ↓
Call MemorySpace.write(address, data)
        ↓
Data persisted to EEPROM/Flash
        ↓
(If all writes complete)
        ↓
Configuration Tool sends COMMAND_UPDATE_COMPLETE
        ↓
MemoryConfigHandler detects command
        ↓
Calls ConfigUpdateService::trigger_update()
```

### Space Allocation in OpenMRNLite Applications

Typical application setup:

```cpp
// In config.h or main.cpp:

// Define memory space for CDI (automatic)
// 0xFF = CDI XML (read-only, auto-served)

// Define memory space for configuration
// 0xFD = Application config struct (registered via accessor)

// Example from async_blink_esp32:
// - Space 0xFD: 128 bytes (config structure)
// - Accessed via ConfigUpdateFlow with EEPROM FD
```

---

## Section 7: File Location Reference

### Core Components Table

| Component | File | Key Lines | Purpose |
|-----------|------|-----------|---------|
| **ConfigUpdateService** | OpenMRNLite/src/utils/ConfigUpdateService.hxx | 40-65 | Virtual interface for service |
| **ConfigUpdateListener** | OpenMRNLite/src/utils/ConfigUpdateListener.hxx | 51-113 | Virtual interface for listeners |
| **DefaultConfigUpdateListener** | OpenMRNLite/src/utils/ConfigUpdateListener.hxx | 104-113 | Base class with auto-registration |
| **ConfigUpdateFlow** | OpenMRNLite/src/openlcb/ConfigUpdateFlow.hxx/cxx | 60-221 | State machine implementation |
| **MemoryConfigHandler** | OpenMRNLite/src/openlcb/MemoryConfigHandler.cxx | 1-1142 | Memory protocol handler |
| **COMMAND_UPDATE_COMPLETE** | OpenMRNLite/src/openlcb/MemoryConfigHandler.cxx | 727-729 | Trigger point |
| **ConfiguredConsumer** | OpenMRNLite/src/openlcb/ConfiguredConsumer.hxx | 87-141 | Example listener - GPIO consumer |
| **ConfiguredProducer** | OpenMRNLite/src/openlcb/ConfiguredProducer.hxx | 95+ | Example listener - GPIO producer |
| **ServoConsumer** | OpenMRNLite/src/openlcb/ServoConsumer.hxx | 16-111 | Example listener - PWM servo |

### Standards Documents

| Standard | File | Key Sections |
|----------|------|--------------|
| **Memory Configuration** | markdown/standards/S-9.7.4.2-MemoryConfiguration-2024-07-22.md | 4.1-4.3 Address spaces, 4.4-4.6 Commands |
| **CDI** | markdown/standards/S-9.7.4.1-ConfigurationDescriptionInformation-2024-07-22.md | XML schema, parameter types |
| **SNIP** | markdown/standards/S-9.7.4.3-SimpleNodeInformation-2024-07-22.md | Node identification format |
| **Memory Config TN** | markdown/standards/TN-9.7.4.2-MemoryConfiguration-2024-07-22.md | Implementation notes, examples |

---

## Section 8: Critical Research Findings

### Finding 1: Version Mismatch = Complete Config Wipe

**Discovery**: Detailed analysis of `ConfigUpdateFlow.cxx` version checking

When `CANONICAL_VERSION` differs from saved config file version:
- **Effect**: Complete factory reset triggered
- **Scope**: ENTIRE configuration wiped (except ACDI bytes 0-127 preserved)
- **Frequency**: Happens on every reboot if versions mismatch
- **Recovery**: None; users lose configuration

**Code Evidence**:
```cpp
if (!reset && cfg.version().read(fd) != expected_version) {
    LOG(VERBOSE, "config version mismatch (%d vs %d), forcing reset.",
        current_version, expected_version);
    reset = true;  // ← Triggers factory_reset() on all listeners
}
```

**Implications**:
- Firmware updates frequently reset user configuration
- No migration path for old config formats
- Fields added in new version appear uninitialized (0xFF)

### Finding 2: No Way to Distinguish First Boot from Reboot

**Discovery**: Analysis of initialization flow shows single-level state tracking

The OpenLCB standard requires nodes to track "initialized" state (ready to process events) vs "uninitialized" (configuration in progress). However:

- `initial_load` flag passed to listeners is set **only at process startup**
- Factory reset does NOT re-trigger `initial_load=true`
- Once process has started, `initial_load=false` for all subsequent config updates
- No persistent flag records "this is the first time this node has ever booted"

**Impact**:
- Listeners cannot implement "first-time setup" differently from "configuration restore"
- Impossible to detect if user is on first boot or rebooting after crash
- No way to populate EEPROM with defaults on very first power-up

### Finding 3: Listeners Iterate Sequentially with No Dependency Ordering

**Discovery**: `ConfigUpdateFlow.cxx` line 133-142

```cpp
Action call_next_listener() {
    // Pop listeners in FIFO order from queue
    if (nextRefresh_ == listeners_.end())
        return call_immediately(STATE(do_initial_load));
    
    l = nextRefresh_.operator->();
    ++nextRefresh_;
}
```

**How It Works**:
- Listeners stored in `std::list`
- Queue is simple FIFO - first registered, first executed
- **No dependency information tracked**
- Iterator walks queue linearly

**Problem Scenario**:
```
Listener A registered first (allocates GPIO 5)
Listener B registered second (uses GPIO 5)

But if B registered first:
  B allocates GPIO 5 for different purpose
  A's allocation fails or conflicts
  → Configuration fails
```

**Missing Feature**: Need dependency declaration system or explicit ordering control

### Finding 4: Asynchronous Support Exists But Rarely Used

**Discovery**: Analysis of listener implementations shows pattern but minimal usage

The framework supports truly asynchronous `apply_configuration()`:

```cpp
virtual UpdateAction apply_configuration(
    int fd, bool initial_load, BarrierNotifiable *done)
{
    // Can return UPDATED immediately
    // Or return ERROR_AGAIN to continue later
    // Then call done->notify() when ready
}
```

**Current Usage**:
- Almost all listeners use `AutoNotify n(done)` wrapper
- This calls `done->notify()` immediately in destructor
- Effectively makes every listener synchronous
- Only a handful of listeners actually use async pattern

**Why It Matters**:
- Async support is there for listeners needing network I/O
- Listeners could fetch config from cloud and apply it
- But complex enough that most devs just block on reads
- Performance suffers if EEPROM reads are slow

### Finding 5: No Status Reporting Per Listener

**Discovery**: ConfigUpdateFlow aggregates return codes but loses granularity

When `trigger_update()` runs, each listener returns:
- `UPDATED` - configuration applied successfully
- `REINIT_NEEDED` - node needs to rescan events
- `REBOOT_NEEDED` - node needs to restart

ConfigUpdateFlow implementation:
```cpp
switch (action) {
    case ConfigUpdateListener::UPDATED:
        break;  // ← No tracking of which listener
    case ConfigUpdateListener::REINIT_NEEDED:
        needsReInit_ = 1;  // ← Simple flag, no listener info
        break;
    case ConfigUpdateListener::REBOOT_NEEDED:
        needsReboot_ = 1;  // ← Simple flag, no listener info
        break;
}
```

**Limitation**: 
- No way to know which listener failed
- Configuration tool cannot report per-listener status
- Debugging which component has issue is hard
- No telemetry on config update success rates

### Finding 6: CDI_FACTORY_RESET Macro Has Usability Issues

**Discovery**: Examination of listener implementations

```cpp
void factory_reset(int fd) OVERRIDE {
    CDI_FACTORY_RESET(cfg_.servo_min_percent);
    CDI_FACTORY_RESET(cfg_.servo_max_percent);
}
```

**Issue**: 
- Macro requires accessor object (like `cfg_.servo_min_percent`)
- If used with wrong type, compile error is cryptic
- No automatic collection of all fields needing reset
- Must manually call for each field
- Easy to forget a field when adding new config parameters

**Better Alternative**: 
- Factory reset method should be auto-generated from CDI
- Or provide memset-like factory reset for entire config block
- Or track "reset defaults" per field in accessor

---

## Section 9: Recommendations for T4.2 Task

### Documentation Needs

For the T4.2 research document, prioritize:

1. **Configuration Update Flow Diagram**
   - Visual representation of listener iteration
   - State transitions (discovery → retrieval → modification → activation)
   - COMMAND_UPDATE_COMPLETE trigger point

2. **Listener Interface Documentation**
   - What `apply_configuration()` must do
   - When to return UPDATED vs REINIT_NEEDED vs REBOOT_NEEDED
   - File descriptor usage patterns
   - Error handling expectations

3. **Configuration Storage Layout**
   - Memory space allocation (0xFE, 0xFD, 0xFC, 0xFB)
   - CDI structure in space 0xFF
   - Version field location
   - ACDI data preservation (bytes 0-127)

4. **First Boot vs Reboot Detection**
   - Current limitation explained
   - Workarounds available
   - Suggested improvements

5. **Listener Registration Patterns**
   - When to register (before stack init, in constructor)
   - Dependency ordering issues
   - Constructor-time registration vs deferred registration

### Gaps That Should Be Addressed

**High Priority** (Impact user experience):
1. **Field migration on version change** - Users losing config is frustrating
2. **Persistent initialization flag** - Cannot implement proper first-boot logic
3. **Per-listener status reporting** - Hard to debug config failures

**Medium Priority** (Impact implementation quality):
4. **Listener dependency ordering** - Some complex applications need this
5. **Configuration validation** - Prevent garbage data corruption
6. **Listener timeout handling** - Stalled listeners should not freeze entire node

**Lower Priority** (Niche use cases):
7. **Enhanced async support** - Only needed for cloud-based listeners
8. **Configuration rollback** - Would require significant architecture change

### Suggested Future Improvements

#### Improvement 1: Add Persistent Initialization Tracking
```cpp
// Add to ConfigUpdateFlow:
// - Track in EEPROM whether node has ever fully initialized
// - Pass "is_first_boot_ever" flag to listeners
// - Allows special first-time setup logic
```

#### Improvement 2: Implement Field-Level Migration
```cpp
// Add to CDI:
// - Version tracking per field, not just overall
// - Migration functions that map old fields to new
// - Example: EventID_v1 (8 bytes) → EventID_v2 (8 bytes) + EventID2 (8 bytes)
```

#### Improvement 3: Add Listener Dependencies
```cpp
// Extend ConfigUpdateListener:
// - declare_dependency(ListenerType* other)
// - ConfigUpdateFlow respects dependency ordering
// - Listeners run topologically sorted, not FIFO
```

#### Improvement 4: Per-Listener Status Reporting
```cpp
// Enhance return codes:
// - Add ConfigUpdateResult struct with listener name + status
// - ConfigUpdateFlow collects all results
// - Can be queried after trigger_update() completes
```

---

## Section 10: Appendix: Key Code Examples

### Example 1: ConfiguredConsumer - Simple Listener Implementation

```cpp
class ConfiguredConsumer : public ConfigUpdateListener
{
public:
    template <class HW>
    ConfiguredConsumer(Node *node, const ConsumerConfig &cfg, 
                      const HW &, const Gpio* g = HW::instance())
        : impl_(node, 0, 0, g)
        , consumer_(&impl_)
        , cfg_(cfg)
    {
        // Auto-register with ConfigUpdateService
        ConfigUpdateService::instance()->register_update_listener(this);
    }

    // Called when configuration is loaded or updated
    UpdateAction apply_configuration(int fd, bool initial_load,
                                     BarrierNotifiable *done) OVERRIDE
    {
        AutoNotify n(done);  // Notify when exiting scope
        
        // Read event IDs from EEPROM via accessor
        EventId cfg_event_on = cfg_.event_on().read(fd);
        EventId cfg_event_off = cfg_.event_off().read(fd);
        
        // Check if configuration actually changed
        if (cfg_event_off != impl_.event_off() ||
            cfg_event_on != impl_.event_on())
        {
            // In-place destruction and reconstruction to update event handlers
            auto saved_gpio = impl_.gpio_;
            auto saved_node = impl_.node();
            consumer_.~BitEventConsumer();
            impl_.Impl::~Impl();
            
            // Reconstruct with new event IDs
            new (&impl_)
                Impl(saved_node, cfg_event_on, cfg_event_off, saved_gpio);
            new (&consumer_) BitEventConsumer(&impl_);
            
            return REINIT_NEEDED;  // Node needs to re-advertise events
        }
        return UPDATED;  // No change needed
    }

    void factory_reset(int fd) OVERRIDE
    {
        // Clear description field to defaults
        cfg_.description().write(fd, "");
    }
};
```

**Key Patterns**:
- Constructor calls `register_update_listener(this)`
- Uses `AutoNotify n(done)` for RAII notification handling
- Reads config via `cfg_.field().read(fd)`
- Returns `REINIT_NEEDED` if event IDs change
- `factory_reset()` resets fields via `CDI_FACTORY_RESET` macro

### Example 2: ServoConsumer - Complex PWM Reconstruction

```cpp
class ServoConsumer : public DefaultConfigUpdateListener
{
public:
    ServoConsumer(Node *node, const ServoConsumerConfig &cfg,
        const uint32_t pwmCountPerMs, PWM *pwm)
        : pwm_(pwm)
        , pwmGpo_(nullptr)
        , gpioImpl_(node, 0, 0, DummyPinWithRead())
        , consumer_(&gpioImpl_)
        , cfg_(cfg)
    {
        // Constructor-based registration via DefaultConfigUpdateListener
    }

    UpdateAction apply_configuration(int fd, bool initial_load,
                                     BarrierNotifiable *done) OVERRIDE
    {
        AutoNotify n(done);

        // Read all servo configuration parameters
        const EventId cfg_event_min = cfg_.event_rotate_min().read(fd);
        const EventId cfg_event_max = cfg_.event_rotate_max().read(fd);
        const int16_t cfg_servo_min_pct = cfg_.servo_min_percent().read(fd);
        const int16_t cfg_servo_max_pct = cfg_.servo_max_percent().read(fd);

        // Calculate PWM tick counts from percentages
        const uint32_t servo_ticks_0 = pwmCountPerMs_ * 1;    // 1ms
        const uint32_t servo_ticks_180 = pwmCountPerMs_ * 2;  // 2ms

        const uint32_t cfg_srv_ticks_min =
            ((100 - cfg_servo_min_pct) * servo_ticks_0 +
                cfg_servo_min_pct * servo_ticks_180) / 100;
        const uint32_t cfg_srv_ticks_max =
            ((100 - cfg_servo_max_pct) * servo_ticks_0 +
                cfg_servo_max_pct * servo_ticks_180) / 100;

        // Preserve current GPIO state across reconstruction
        const bool was_set = pwmGpo_ && (pwmGpo_->read() == Gpio::SET);

        // Check if anything actually changed
        if (!pwmGpo_ ||
            cfg_event_min != gpioImpl_.event_off() ||
            cfg_event_max != gpioImpl_.event_on() ||
            cfg_srv_ticks_min != pwmGpo_->get_off_counts() ||
            cfg_srv_ticks_max != pwmGpo_->get_on_counts())
        {
            auto saved_node = gpioImpl_.node();

            // In-place destruction and reconstruction
            consumer_.~BitEventConsumer();
            gpioImpl_.~GPIOBit();

            // Create new PWM GPIO with updated tick counts
            pwmGpo_.reset(new PWMGPO(pwm_,
                /*on_counts=*/cfg_srv_ticks_max,
                /*off_counts=*/cfg_srv_ticks_min));
            pwmGpo_->write(was_set ? Gpio::SET : Gpio::CLR);

            // Reconstruct event handler with new event IDs
            new (&gpioImpl_) GPIOBit(
                saved_node, cfg_event_min, cfg_event_max, pwmGpo_.get());
            new (&consumer_) BitEventConsumer(&gpioImpl_);

            return REINIT_NEEDED;
        }
        return UPDATED;
    }
};
```

**Advanced Patterns**:
- Reads multiple related parameters atomically
- Performs calculations based on configuration
- Reconstructs multiple objects in-place
- Preserves state (GPIO level) across reconstruction
- Returns REINIT_NEEDED for servo parameter changes

### Example 3: trigger_update() Call Chain

**Initiation** - `MemoryConfigHandler.cpp`:
```cpp
case MemoryConfigDefs::COMMAND_UPDATE_COMPLETE:
{
    Singleton<ConfigUpdateService>::instance()->trigger_update();
    break;
}
```

**State Machine Entry** - `ConfigUpdateFlow.cxx`:
```cpp
void trigger_update() override
{
    AtomicHolder h(this);
    nextRefresh_ = listeners_.begin();  // Reset iterator
    needsReboot_ = 0;
    needsReInit_ = 0;
    
    if (is_state(exit().next_state()))  // If not already running
    {
        start_flow(STATE(call_next_listener));  // Start state machine
    }
}
```

**Listener Iteration** - `ConfigUpdateFlow.cxx`:
```cpp
Action call_next_listener()
{
    ConfigUpdateListener *l = nullptr;
    {
        AtomicHolder h(this);
        if (nextRefresh_ == listeners_.end())
        {
            return call_immediately(STATE(do_initial_load));  // All listeners done
        }
        l = nextRefresh_.operator->();
        ++nextRefresh_;  // Move to next listener
    }
    return call_listener(l, false);  // Call this listener
}
```

**Listener Callback** - `ConfigUpdateFlow.cxx`:
```cpp
Action call_listener(ConfigUpdateListener *l, bool is_initial)
{
    if (fd_ < 0)
    {
        DIE("CONFIG_FILENAME not specified");
    }
    
    // Call listener's apply_configuration method
    ConfigUpdateListener::UpdateAction action =
        l->apply_configuration(fd_, is_initial, n_.reset(this));
    
    // Track what listener requested
    switch (action)
    {
        case ConfigUpdateListener::UPDATED:
            break;  // No special action
        case ConfigUpdateListener::REINIT_NEEDED:
            needsReInit_ = 1;
            break;
        case ConfigUpdateListener::REBOOT_NEEDED:
            needsReboot_ = 1;
            break;
    }
    
    return wait();  // Wait for listener to call done->notify()
}
```

**Final Actions** - `ConfigUpdateFlow.cxx`:
```cpp
Action apply_action()
{
    // Execute required actions based on listener requests
    if (needsReboot_)
    {
#if OPENMRN_FEATURE_REBOOT
        reboot();  // Hard reboot the entire node
#endif
    }
    
    if (needsReInit_)
    {
        // Start Node Initialization Complete message flow
        new ReinitAllNodes(static_cast<If *>(service()));
    }
    
    return exit();  // State machine done
}
```

**Complete Call Sequence**:
```
Configuration Tool sends COMMAND_UPDATE_COMPLETE datagram
    ↓
MemoryConfigHandler receives datagram
    ↓
Calls trigger_update()
    ↓
ConfigUpdateFlow::trigger_update() invoked
    ↓
STATE(call_next_listener) entered
    ↓
For each listener:
    call_listener(listener, is_initial=false)
        ↓
        listener->apply_configuration(fd, false, done)
            ↓
            Listener reads config from fd
            Listener applies new configuration
            Listener calls done->notify() via AutoNotify destructor
        ↓
    Returns UPDATED/REINIT_NEEDED/REBOOT_NEEDED
    ↓
Next listener processed
    ↓
STATE(do_initial_load)
    ↓
STATE(apply_action)
    ↓
If needsReboot_: reboot()
If needsReInit_: Start ReinitAllNodes
    ↓
Exit state machine
```

### Example 4: COMMAND_UPDATE_COMPLETE Handling

**Datagram Reception** - `MemoryConfigHandler.cpp`:

```cpp
Action handle_write_datagram() {
    uint8_t command = payload[1] & MemoryConfigDefs::COMMAND_MASK;
    
    switch (command) {
        case MemoryConfigDefs::COMMAND_WRITE:
            // ... process write to address space
            
        case MemoryConfigDefs::COMMAND_READ:
            // ... process read from address space
            
        case MemoryConfigDefs::COMMAND_UPDATE_COMPLETE:
        {
            // Trigger configuration update on all listeners
            Singleton<ConfigUpdateService>::instance()->trigger_update();
            break;
        }
        
        case MemoryConfigDefs::COMMAND_FACTORY_RESET:
        {
            // Trigger factory reset on all listeners
            updateService_->factory_reset();
            break;
        }
    }
}
```

**Key Point**: 
- COMMAND_UPDATE_COMPLETE is received as part of datagram
- Causes immediate `trigger_update()` call
- Asynchronous state machine starts
- Configuration tool doesn't wait for completion
- Node sends "Node Initialization Complete" message when ready

---

## Section 7: Configuration Field Patterns and Implementation

### Overview

OpenMRNLite provides a rich set of configuration field types with corresponding CDI macros for defining configurable parameters. This section catalogs the available patterns for implementing different configuration value types, essential for T4.3 (adding configurable blink interval).

### Integer Configuration Values

**Available Types** (all big-endian, unsigned and signed variants):

| Type | Storage | Range | Typical Use |
|------|---------|-------|------------|
| `Uint8ConfigEntry` | 1 byte | 0–255 | Flags, counts, small selections |
| `Uint16ConfigEntry` | 2 bytes | 0–65,535 | Intervals, counts, GPIO pins |
| `Uint32ConfigEntry` | 4 bytes | 0–4,294,967,295 | Timestamps, large counters |
| `Uint64ConfigEntry` | 8 bytes | 0–18,446,744,073,709,551,615 | Event IDs (special type) |
| `Int8ConfigEntry` | 1 byte | -128–127 | Signed values |
| `Int16ConfigEntry` | 2 bytes | -32,768–32,767 | Calibration values, offsets |
| `Int32ConfigEntry` | 4 bytes | -2,147,483,648–2,147,483,647 | Large signed values |
| `Int64ConfigEntry` | 8 bytes | ±9,223,372,036,854,775,807 | Large signed timestamps |

**CDI Macro Pattern** for Uint16 (example: blink interval in milliseconds):

```cpp
CDI_GROUP_ENTRY(blink_interval,          // Field name in config struct
                Uint16ConfigEntry,        // Type
                Default(1000),            // Default value (milliseconds)
                Min(100),                 // Minimum allowed
                Max(30000),               // Maximum allowed (30 seconds)
                Name("Blink Interval"),
                Description("Milliseconds between blink events"));
```

**Memory Layout**:
- Value stored big-endian in configuration memory
- Actual position determined by offset and struct layout
- Configuration tool automatically knows range and type from CDI XML

**Runtime Access Pattern**:

```cpp
// After apply_configuration() receives file descriptor:
struct ConfigDef cfg(0);  // Create temporary config object

// Read value from config file at fd
uint16_t interval = cfg.seg().blink_interval().read(fd);

// Use in code
unsigned long next_event_time = millis() + interval;
```

**Validation Options**:
- `Min()` / `Max()` - Configuration tool enforces client-side
- `CDI_READ_TRIMMED` - Trim out-of-range values to nearest boundary
- `CDI_READ_TRIM_DEFAULT` - Use default if out of range
- Runtime validation in listener code (fallback pattern)

---

### Boolean Configuration Values

**Implementation**: Boolean values are implemented as `Uint8ConfigEntry` with `MapValues` constraint.

**CDI Pattern**:

```cpp
CDI_GROUP_ENTRY(enable_wifi,
                Uint8ConfigEntry,
                Default(1),               // 1 = enabled by default
                MapValues(Name("No"), Name("Yes")),  // 0=No, 1=Yes
                Name("Enable WiFi"),
                Description("Enable WiFi connectivity"));
```

**CDI XML Output**:
```xml
<map>
  <relation><property>0</property><value>No</value></relation>
  <relation><property>1</property><value>Yes</value></relation>
</map>
```

**UI Representation**:
- JMRI shows as checkbox or Yes/No dropdown
- Storage: 1 byte (0 or 1)
- Memory-efficient for simple binary choices

**Runtime Access**:

```cpp
uint8_t enabled = cfg.seg().enable_wifi().read(fd);
if (enabled) {
    init_wifi();
}
```

---

### Multi-Choice Configuration Values

**Implementation**: Uses `Uint8ConfigEntry` (or larger int type) with `MapValues` for string labels.

**Pattern**: Numeric value maps to user-friendly label in CDI.

**Example: GPIO Function Selection**

```cpp
CDI_GROUP_ENTRY(gpio_mode,
                Uint8ConfigEntry,
                Default(0),               // Default to Input
                MapValues(
                    Name("Input (Pull-Up)"),    // Value 0
                    Name("Input (Floating)"),   // Value 1
                    Name("Output"),             // Value 2
                    Name("PWM Output")          // Value 3
                ),
                Name("GPIO Function"),
                Description("Select GPIO 5 operating mode"));
```

**CDI XML Output**:
```xml
<map>
  <relation><property>0</property><value>Input (Pull-Up)</value></relation>
  <relation><property>1</property><value>Input (Floating)</value></relation>
  <relation><property>2</property><value>Output</value></relation>
  <relation><property>3</property><value>PWM Output</value></relation>
</map>
```

**UI Representation**:
- JMRI displays as dropdown menu with 4 options
- User selects by label; underlying numeric value written to memory

**Runtime Access**:

```cpp
uint8_t mode = cfg.seg().gpio_mode().read(fd);
switch (mode) {
    case 0: configure_input_pullup(GPIO_5); break;
    case 1: configure_input_floating(GPIO_5); break;
    case 2: configure_output(GPIO_5); break;
    case 3: configure_pwm(GPIO_5); break;
}
```

**Multi-Byte Example**: Same pattern works with `Uint16ConfigEntry` or larger types if needed.

---

### Event ID Configuration Values

**Special Type**: `EventConfigEntry` (specialized `Uint64ConfigEntry`)

**Purpose**: Configure which OpenLCB events a node listens to or produces.

**CDI Pattern**:

```cpp
CDI_GROUP_ENTRY(event_on,
                EventConfigEntry,
                Default(0x0502010202000000ULL),  // Default event ID
                Name("Event ID (Turn On)"),
                Description("Event to listen for"));
```

**Key Differences from Uint64**:
- Automatic event handler registration tracking
- 8-byte big-endian storage
- Event IDs displayed as hexadecimal in JMRI
- Framework can validate event ID syntax (if implemented)

**Runtime Access**:

```cpp
uint64_t event_id = cfg.seg().event_on().read(fd);
```

---

### String Configuration Values

**Implementation**: `StringConfigEntry<SIZE>` template (null-terminated C-strings).

**CDI Pattern**:

```cpp
CDI_GROUP_ENTRY(wifi_ssid,
                StringConfigEntry<32>,   // Max 31 chars + null terminator
                Default("MyWiFi"),
                Name("WiFi SSID"),
                Description("Network name"));
```

**Memory Layout**:
- `SIZE` bytes allocated in config structure
- Null-terminated; actual string may be shorter
- Automatic truncation to `SIZE-1` characters

**Runtime Access**:

```cpp
char ssid[32];
cfg.seg().wifi_ssid().read(fd, ssid, sizeof(ssid));
// ssid now contains null-terminated string
```

---

### Macro System and CDI Definition

**Core Macros** (in ConfigRepresentation.hxx):

| Macro | Purpose | Example |
|-------|---------|---------|
| `CDI_GROUP()` | Begin configuration group/segment | `CDI_GROUP(SettingsSegment, Segment(...), Offset(128));` |
| `CDI_GROUP_ENTRY()` | Single configuration field | `CDI_GROUP_ENTRY(interval, Uint16ConfigEntry, Default(1000), ...);` |
| `CDI_GROUP_END()` | End configuration group | `CDI_GROUP_END();` |

**Common Constraints** (passed as macro arguments):

| Constraint | Usage | Example |
|------------|-------|---------|
| `Default(value)` | Initial/reset value | `Default(1000)` |
| `Min(value)` | Minimum allowed | `Min(100)` |
| `Max(value)` | Maximum allowed | `Max(30000)` |
| `Name(string)` | Display name in JMRI | `Name("Blink Interval")` |
| `Description(string)` | Help text in JMRI | `Description("Milliseconds...")` |
| `MapValues(...)` | Multi-choice labels | `MapValues(Name("Off"), Name("On"))` |
| `Hints(string)` | Additional metadata | `Hints("nonzero")` |

---

### Factory Reset Helper Macro

**Purpose**: Automatically populate SNIP dynamic data (node name, description) on first boot.

**Macro**: `CDI_FACTORY_RESET(object, field, value)`

**Example** (in factory_reset() method):

```cpp
void factory_reset(int fd) override
{
    // Initialize SNIP data
    CDI_FACTORY_RESET(cfg, userinfo().name(), "async_blink");
    CDI_FACTORY_RESET(cfg, userinfo().description(), "ESP32 Blink demo");
    
    // Initialize application config defaults
    // (explicit writes; config fields already have defaults)
}
```

**Limitations**:
- Only works with accessor types that support the pattern
- Requires matching method chain to reach the field
- Alternative: manual `write()` calls if macro causes issues

---

### Configuration Access Patterns

**Pattern 1: Read in apply_configuration()**

```cpp
class MyListener : public DefaultConfigUpdateListener {
    UpdateAction apply_configuration(int fd, bool initial_load,
                                     BarrierNotifiable *done) OVERRIDE {
        AutoNotify n(done);
        
        // Create config object and read value
        struct ConfigDef cfg(0);
        uint16_t interval = cfg.seg().blink_interval().read(fd);
        
        // Apply configuration
        g_blink_interval = interval;
        
        return UPDATED;
    }
};
```

**Pattern 2: Store in global or member variable**

```cpp
class OpenLCBNode {
    uint16_t blink_interval_;
    
    UpdateAction apply_configuration(int fd, bool initial_load,
                                     BarrierNotifiable *done) OVERRIDE {
        AutoNotify n(done);
        
        struct ConfigDef cfg(0);
        blink_interval_ = cfg.seg().blink_interval().read(fd);
        
        return UPDATED;
    }
};
```

**Pattern 3: Complex field with validation**

```cpp
UpdateAction apply_configuration(int fd, bool initial_load,
                                 BarrierNotifiable *done) OVERRIDE {
    AutoNotify n(done);
    
    struct ConfigDef cfg(0);
    uint16_t interval = cfg.seg().blink_interval().read(fd);
    
    // Validate
    if (interval < 100) {
        // Out of range; use default
        interval = 1000;
        Serial.println("Warning: interval out of range, using default");
    }
    
    g_blink_interval = interval;
    return UPDATED;
}
```

---

### Relevant Source Files

| File | Location | Purpose |
|------|----------|---------|
| `ConfigRepresentation.hxx` | OpenMRNLite/src/openlcb/ | CDI macro definitions |
| `ConfigEntry.hxx` | OpenMRNLite/src/openlcb/ | Field type definitions (Uint8, Int32, etc.) |
| `MemoryConfig.hxx` | OpenMRNLite/src/openlcb/ | Memory space definitions |
| `ConfiguredConsumer.hxx` | OpenMRNLite/src/openlcb/ | Example listener with GPIO config |
| `ConfiguredProducer.hxx` | OpenMRNLite/src/openlcb/ | Example listener with event config |
| `MultiConfiguredConsumer.hxx` | OpenMRNLite/src/openlcb/ | Multiple consumers in one listener |
| `async_blink_esp32/config.h` | test/async_blink_esp32/include/ | Current example config |
| `async_blink_esp32/main.cpp` | test/async_blink_esp32/src/ | Example of reading config |

---

### Implementation Checklist for T4.3

To add a configurable blink interval:

- [ ] Add new `Uint16ConfigEntry` field to config.h CDI structure
- [ ] Set appropriate Default, Min, Max constraints
- [ ] Create config listener class to read the value on startup
- [ ] Update apply_configuration() to read new field and store in global
- [ ] Update loop() to use stored configuration value instead of constant
- [ ] Test with JMRI: verify CDI shows new field, can modify, persists after reboot

---

### Advanced Configuration Constructs

Beyond basic field types, OpenMRNLite provides advanced constructs for complex configuration scenarios.

#### RepeatedGroup: Arrays of Configuration Items

**Purpose**: Define arrays of identical configuration structures (e.g., multiple GPIO outputs, multiple WiFi networks).

**Template**: `RepeatedGroup<BaseGroupType, COUNT>`

**Example from IOBoard**:

```cpp
constexpr uint8_t NUM_OUTPUTS = 8;
constexpr uint8_t NUM_INPUTS = 8;

using AllConsumers = RepeatedGroup<ConsumerConfig, NUM_OUTPUTS>;  // Array of 8 outputs
using AllProducers = RepeatedGroup<ProducerConfig, NUM_INPUTS>;   // Array of 8 inputs

CDI_GROUP_ENTRY(consumers, AllConsumers, Name("Outputs"), RepName("Output"));
CDI_GROUP_ENTRY(producers, AllProducers, Name("Inputs"), RepName("Input"));
```

**CDI XML Output**:
```xml
<group name="Outputs" replication="8">
  <name>Output</name>  <!-- RepName: singular form for each item -->
  <!-- ConsumerConfig fields repeated 8 times -->
</group>
```

**Memory Layout**:
- Linear array in config memory
- Each repeat contains full ConsumerConfig structure
- Total size: `sizeof(ConsumerConfig) * 8` bytes
- Offset of repeat[i] = `base_offset + (i * sizeof(ConsumerConfig))`

**Runtime Access Pattern**:

```cpp
struct ConfigDef cfg(0);

// Access individual repeat by index
uint64_t event_id_0 = cfg.seg().consumers()[0].event().read(fd);
uint64_t event_id_1 = cfg.seg().consumers()[1].event().read(fd);

// Typical loop pattern
for (int i = 0; i < NUM_OUTPUTS; i++) {
    uint64_t event_id = cfg.seg().consumers()[i].event().read(fd);
    configure_consumer_event(i, event_id);
}
```

**UI Representation in JMRI**:
- Shows as expandable section with numbered items
- Each item shows the configurable fields from base type
- User can configure all 8 outputs independently

**Macro**: `RepName(string)` 
- Singular form shown for each item in repeated group
- "Output" instead of "Outputs" for individual items

**Design Pattern**: Used when application needs identical configuration for multiple hardware instances (GPIO pins, network settings, servo channels, etc.)

---

#### Special Field Types

**InternalConfigData**

Purpose: Framework-managed configuration data (version, internal state).

```cpp
CDI_GROUP_ENTRY(internal_config, InternalConfigData);
```

- Automatically included in CDI
- Managed by OpenMRNLite; typically not directly accessed by listeners
- Stores version info for factory reset detection
- Should be first entry in config segment

**Identification**

Purpose: SNIP (Simple Node Information Protocol) static data integration.

```cpp
CDI_GROUP_ENTRY(ident, Identification);
```

- Auto-populated from `SNIP_STATIC_DATA`
- Displays manufacturer, model, hardware version, software version
- Read-only in configuration; set at compile time
- Example:
```cpp
extern const SimpleNodeStaticValues SNIP_STATIC_DATA = {
    4,                              // Version (always 4)
    "OpenMRN",                      // Manufacturer
    "Arduino IO Board (WiFi)",      // Model
    ARDUINO_VARIANT,                // Hardware version
    "1.00"                          // Software version
};
```

**Acdi**

Purpose: ACDI (Application CDI) segment marker.

```cpp
CDI_GROUP_ENTRY(acdi, Acdi);
```

- Standard OpenLCB segment for dynamic node information
- Auto-included by framework

**UserInfoSegment**

Purpose: User-editable node metadata (name, description).

```cpp
CDI_GROUP_ENTRY(userinfo, UserInfoSegment, Name("User Info"));
```

- Standard segment for SNIP dynamic data
- Allows user to set friendly node name in JMRI
- Persisted in configuration memory
- Example content:
  ```
  name: "async_blink"
  description: "ESP32 Blink demo"
  ```

**WiFiConfiguration**

Purpose: Specialized configuration for ESP32 WiFi nodes.

Location: `freertos_drivers/esp32/Esp32WiFiConfiguration.hxx`

```cpp
CDI_GROUP_ENTRY(wifi, WiFiConfiguration, Name("WiFi Configuration"));
```

Contains nested groups:
- SSID, password
- Connection mode (client/hub/both)
- Hub configuration (if acting as hub)
- Static IP, DNS settings (optional)

Example nested structure:
```cpp
CDI_GROUP(WiFiConfiguration, ...);
  CDI_GROUP_ENTRY(ssid, StringConfigEntry<32>, Name("SSID"), ...);
  CDI_GROUP_ENTRY(password, StringConfigEntry<32>, Name("Password"), ...);
  CDI_GROUP_ENTRY(mode, Uint8ConfigEntry, MapValues(...), Name("Mode"), ...);
  CDI_GROUP_ENTRY(hub_config, HubConfiguration, Name("Hub Settings"), ...);
CDI_GROUP_END();
```

**ServoConsumerConfig**

Purpose: Configuration for PWM servo control.

Location: `openlcb/ServoConsumer.hxx`

Includes:
- Event IDs to trigger servo movement
- PWM pulse width min/max
- Servo movement speed

---

#### Segment and Memory Management

**Segment()**: Allocates a memory space for configuration.

```cpp
// Main configuration in SPACE_CONFIG (0xFD)
CDI_GROUP(IoBoardSegment, Segment(MemoryConfigDefs::SPACE_CONFIG), Offset(128));
```

**Standard Memory Spaces**:

| Space | Purpose | Typical Use |
|-------|---------|------------|
| MainCdi | Special: CDI definition (-2) | Not directly used |
| SPACE_ACDI_USR | ACDI user data (0x00) | Node name, description |
| SPACE_ACDI | ACDI (internal) | Auto-generated |
| SPACE_CONFIG | Configuration (0xFD) | Main application config |

**Offset()**: Byte position within segment.

```cpp
// Start main config at byte 128 (leaving room for ACDI)
CDI_GROUP(IoBoardSegment, Segment(...), Offset(128));
```

- Compile-time calculation
- Allows multiple logical configs in one space
- Must account for cumulative structure sizes

**Multi-Segment Example**:

```cpp
CDI_GROUP(Config1, Segment(SPACE_CONFIG), Offset(0));
  // ... fields
CDI_GROUP_END();

CDI_GROUP(Config2, Segment(SPACE_CONFIG), Offset(256));
  // ... more fields at offset 256
CDI_GROUP_END();
```

---

#### Advanced Constraints and Metadata

**Hidden()**

Allocate memory space without showing in JMRI UI.

```cpp
CDI_GROUP_ENTRY(reserved_field, Uint32ConfigEntry, Hidden());
```

- Field is read/written but not visible to user
- Useful for internal state, reserved space, future expansion

**SkipInit()**

Don't initialize this event ID when first created.

```cpp
CDI_GROUP_ENTRY(event_optional, EventConfigEntry, SkipInit());
```

- Field remains 0xFFFFFFFFFFFFFFFF (uninitialized)
- User must explicitly configure
- Common for optional event bindings

**Hints()**

Provide UI hints to configuration tools.

```cpp
CDI_GROUP_ENTRY(count, Uint16ConfigEntry, Hints("nonzero"));
```

Common hints: "nonzero", "hex", "decimal"

---

#### Configuration Nesting and Complex Structures

**Nested Groups**

Groups can contain other groups:

```cpp
CDI_GROUP(WiFiConfiguration, ...);
  CDI_GROUP_ENTRY(network, StringConfigEntry<32>, Name("Network Name"), ...);
  
  // Nested group
  CDI_GROUP_ENTRY(hub_config, HubConfiguration, Name("Hub Settings"));
    // HubConfiguration contains its own entries
  
  CDI_GROUP_ENTRY(security, SecuritySettings, Name("Security"));
    // SecuritySettings contains its own entries
CDI_GROUP_END();
```

**JMRI Display**:
- Hierarchical expandable tree
- Each level has its own configuration section
- Memory layout: sequential concatenation of all nested fields

**Nested RepeatedGroups** (with caution):

Possible but use carefully:
```cpp
using ArrayOfSettings = RepeatedGroup<NestedConfig, 4>;

CDI_GROUP(ComplexConfig, ...);
  CDI_GROUP_ENTRY(items, ArrayOfSettings, Name("Items"), RepName("Item"));
CDI_GROUP_END();
```

Limitation: VirtualMemorySpace needs proper size calculation for nested repeats.

---

#### Real-World Example: IOBoard Configuration

Complete configuration structure showing multiple patterns:

```cpp
// 1. Repeated groups defined
using AllConsumers = RepeatedGroup<ConsumerConfig, NUM_OUTPUTS>;  // 8 GPIO outputs
using AllProducers = RepeatedGroup<ProducerConfig, NUM_INPUTS>;   // 8 GPIO inputs

// 2. Main configuration segment
CDI_GROUP(IoBoardSegment, Segment(MemoryConfigDefs::SPACE_CONFIG), Offset(128));
  CDI_GROUP_ENTRY(internal_config, InternalConfigData);           // Framework data
  CDI_GROUP_ENTRY(consumers, AllConsumers,                         // Repeated: 8x
                  Name("Outputs"), RepName("Output"));
  CDI_GROUP_ENTRY(producers, AllProducers,                         // Repeated: 8x
                  Name("Inputs"), RepName("Input"));
#if defined(USE_WIFI)
  CDI_GROUP_ENTRY(wifi, WiFiConfiguration,                         // Nested config
                  Name("WiFi Configuration"));
#endif
CDI_GROUP_END();

// 3. Top-level CDI definition
CDI_GROUP(ConfigDef, MainCdi());
  CDI_GROUP_ENTRY(ident, Identification);                         // SNIP static
  CDI_GROUP_ENTRY(acdi, Acdi);                                    // ACDI segment
  CDI_GROUP_ENTRY(userinfo, UserInfoSegment,                      // SNIP dynamic
                  Name("User Info"));
  CDI_GROUP_ENTRY(seg, IoBoardSegment, Name("Settings"));         // Main config
CDI_GROUP_END();
```

**Memory Layout**:
```
SPACE_CONFIG (0xFD):
  Offset 0-127: ACDI data (managed separately)
  
  Offset 128+: IoBoardSegment
    [0-N]: InternalConfigData
    [N+0 to N+M]: AllConsumers[0] (ConsumerConfig)
    [N+M to N+2M]: AllConsumers[1] (ConsumerConfig)
    ... (repeat 8 times)
    [N+8M to N+8M+P]: AllProducers[0] (ProducerConfig)
    ... (repeat 8 times)
    [Final offset]: WiFiConfiguration fields
```

**JMRI Display**:
```
Settings
├── Outputs (expandable)
│   ├── Output 0 (event ID, pin, polarity)
│   ├── Output 1
│   ├── ...
│   └── Output 7
├── Inputs (expandable)
│   ├── Input 0 (event ID, pin, debounce)
│   ├── Input 1
│   ├── ...
│   └── Input 7
└── WiFi Configuration (expandable)
    ├── SSID
    ├── Password
    ├── Mode
    └── Hub Settings
```

---

#### Listener Runtime Integration

How listeners access repeated group configuration:

```cpp
class MultiOutputListener : public DefaultConfigUpdateListener {
    UpdateAction apply_configuration(int fd, bool initial_load,
                                     BarrierNotifiable *done) OVERRIDE {
        AutoNotify n(done);
        
        struct ConfigDef cfg(0);
        
        // Access each repeated item
        for (int i = 0; i < NUM_OUTPUTS; i++) {
            uint64_t event_id = cfg.seg().consumers()[i].event().read(fd);
            uint8_t gpio_pin = cfg.seg().consumers()[i].pin().read(fd);
            
            // Configure hardware
            configure_output(i, gpio_pin, event_id);
        }
        
        return UPDATED;
    }
};
```

**Key Points**:
- Index operator `[i]` accesses individual repeat
- Read operations specify field path through nesting
- All config is read at once in apply_configuration()
- Changes persist via OpenMRN's config file mechanism

---

## Summary

The Configuration Update Service is a sophisticated publish-subscribe system enabling runtime configuration of OpenLCB nodes. The OpenMRNLite implementation provides:

- ✅ Robust state machine for sequential listener execution
- ✅ Asynchronous operation support via Notifiable pattern
- ✅ Full datagram protocol support for memory operations
- ✅ Factory reset capabilities
- ✅ Version tracking and mismatch detection

However, gaps remain in:
- ❌ Persistent initialization state tracking
- ❌ Field-level configuration migration
- ❌ Listener dependency ordering
- ❌ Per-listener status reporting
- ❌ Configuration validation

These gaps don't prevent basic operation but limit sophisticated use cases. T4.2 should document both the working implementation and these limitations for future improvement efforts.

---

**Document Last Updated**: December 24, 2025  
**Research Scope**: OpenMRNLite versions in LCC workspace + OpenLCB Standards S-9.7.4.x series
