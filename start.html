<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Getting Started - OpenLCB Technical Introduction</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro_node.html"><strong aria-hidden="true">1.1.</strong> Node</a></li><li class="chapter-item expanded "><a href="intro_can.html"><strong aria-hidden="true">1.2.</strong> CAN</a></li><li class="chapter-item expanded "><a href="intro_async_blink.html"><strong aria-hidden="true">1.3.</strong> Node Startup Sequence</a></li><li class="chapter-item expanded "><a href="intro_ab_events.html"><strong aria-hidden="true">1.4.</strong> Events and Run Mode</a></li></ol></li><li class="chapter-item expanded "><a href="start.html" class="active"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="openmrn-architecture.html"><strong aria-hidden="true">3.</strong> OpenMRN-Lite Architecture &amp; Capabilities</a></li><li class="chapter-item expanded "><a href="esp32-arduino.html"><strong aria-hidden="true">4.</strong> ESP32 with Arduino &amp; PlatformIO</a></li><li class="chapter-item expanded "><a href="gpio-hardware.html"><strong aria-hidden="true">5.</strong> Physical I/O with GPIO</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">OpenLCB Technical Introduction</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>In the previous chapter, you learned about OpenLCB concepts: nodes, transport layers, startup sequences, and the producer/consumer event model. Now it's time to build something real.</p>
<p>This chapter will guide you through the choices we've made for this book and prepare you for hands-on work in the next chapter.</p>
<h2 id="what-were-building"><a class="header" href="#what-were-building">What We're Building</a></h2>
<p>We're going to build a simple but complete OpenLCB node that demonstrates the core concepts:</p>
<p><strong>Hardware</strong>: An ESP32 microcontroller with:</p>
<ul>
<li>A push button (input) - produces an OpenLCB event when pressed</li>
<li>An LED (output) - consumes OpenLCB events to turn on/off</li>
<li>WiFi connectivity - connects to your home network</li>
</ul>
<p><strong>Software</strong>: </p>
<ul>
<li>OpenMRNLite library - provides the complete OpenLCB protocol stack</li>
<li>Arduino framework - familiar development environment</li>
<li>PlatformIO - modern build system and IDE integration</li>
</ul>
<p><strong>Network Integration</strong>:</p>
<ul>
<li>JMRI monitoring tool - see OpenLCB messages in real-time</li>
<li>TCP/GridConnect protocol - network-based communication</li>
<li>Multi-node capable - your node can interact with other OpenLCB devices</li>
</ul>
<p>This example is intentionally simple to focus on learning. Real layout nodes can have dozens of inputs/outputs, configuration systems, and specialized protocols—we'll cover those in future chapters.</p>
<h2 id="why-wifitcp-first"><a class="header" href="#why-wifitcp-first">Why WiFi/TCP First?</a></h2>
<p>As mentioned in Chapter 1, OpenLCB works over multiple physical transports. We're starting with WiFi and TCP for several practical reasons:</p>
<p><strong>For Learning</strong>:</p>
<ul>
<li><strong>No special hardware required</strong> - ESP32 boards have WiFi built-in, no CAN transceivers needed</li>
<li><strong>Easy monitoring</strong> - standard network tools and JMRI can capture all traffic</li>
<li><strong>Faster iteration</strong> - wireless upload and debugging without physical bus connections</li>
<li><strong>Lower barrier to entry</strong> - get started with just a microcontroller and breadboard</li>
</ul>
<p><strong>Same Protocols</strong>: The OpenLCB message formats, node startup, and event handling work identically over WiFi/TCP and CAN. Everything you learn here transfers directly to CAN-based implementations.</p>
<p><strong>CAN Is Still Important</strong>: Traditional LCC installations use CAN bus, and for good reason:</p>
<ul>
<li>Excellent noise immunity for layout environments</li>
<li>Built-in collision handling and arbitration</li>
<li>Two-wire bus with simple termination</li>
<li>Industry-proven reliability</li>
</ul>
<p>We'll cover adding CAN hardware in future chapters. For now, WiFi/TCP lets you focus on understanding OpenLCB without hardware complexity.</p>
<h2 id="library-choice-openmrn-lite"><a class="header" href="#library-choice-openmrn-lite">Library Choice: OpenMRN-Lite</a></h2>
<p>Before choosing a microcontroller, we need to choose an OpenLCB library. There are two main options:</p>
<p><strong>Full OpenMRN</strong> uses FreeRTOS and POSIX threading, giving you access to advanced features like virtual nodes and traction protocol. But it requires Linux, macOS, Windows, or native ESP-IDF—a full real-time operating system environment. The learning curve is steep: you need to understand threading, mutexes, message queues, and how RTOS schedulers work <em>before</em> you can focus on OpenLCB itself.</p>
<p><strong>OpenMRN-Lite</strong> is the Arduino version: single-threaded, no RTOS required, designed specifically for learning and hobby projects. It has everything you need for your first OpenLCB node (events, producers/consumers, CDI configuration, CAN/TCP support). Most importantly, it lets you focus on OpenLCB concepts without fighting with threading complexity.</p>
<p><strong>We're choosing OpenMRN-Lite</strong> for this book because:</p>
<ul>
<li><strong>Lower learning curve</strong> - Arduino's simple <code>setup()</code>/<code>loop()</code> model is familiar to most hobbyists and embedded developers</li>
<li><strong>Faster progress</strong> - You'll have working code and see results within hours, not days</li>
<li><strong>Proven examples</strong> - OpenMRN-Lite has excellent examples (IOBoard, WifiCanBridge) that demonstrate real patterns</li>
<li><strong>Future flexibility</strong> - Once you understand OpenLCB concepts, upgrading to full OpenMRN (with FreeRTOS) becomes a natural next step, not a barrier</li>
</ul>
<p>This is not a limitation—it's a pedagogical choice. You can absolutely build production OpenLCB nodes with OpenMRN-Lite. Chapter 2.5 goes deeper into what OpenMRN-Lite supports and when you might want to switch toolchains.</p>
<h2 id="platform-choice-esp32"><a class="header" href="#platform-choice-esp32">Platform Choice: ESP32</a></h2>
<p>We've chosen the ESP32 microcontroller platform for this book because it's one of the best-supported platforms for OpenMRN-Lite:</p>
<p><strong>Why ESP32 for OpenMRN-Lite?</strong></p>
<ul>
<li><strong>Excellent Arduino support</strong> - Arduino framework is mature and stable on ESP32</li>
<li><strong>WiFi built-in</strong> - Perfect match for our WiFi/TCP transport choice</li>
<li><strong>CAN capable</strong> - Built-in CAN controller for adding CAN hardware in future chapters</li>
<li><strong>Affordable</strong> - Development boards are $5-15 USD</li>
<li><strong>Powerful</strong> - Dual-core processor, plenty of memory for OpenMRNLite applications</li>
<li><strong>GPIO-rich</strong> - Enough pins for inputs, outputs, and expansion</li>
</ul>
<p><strong>Other Platforms with OpenMRN-Lite Support</strong>: OpenMRN-Lite works on other Arduino-compatible boards:</p>
<ul>
<li>STM32 family (Nucleo boards) via Arduino core</li>
<li>Arduino variants (Mega, Due)</li>
<li>Other ESP32 variants (ESP32-S3, ESP32-C3)</li>
</ul>
<p>If you have a different board available, you can likely adapt the examples. Chapter 2.5 has more details on platform trade-offs. For now, ESP32 is the best starting point: affordable, well-documented, and fully supported by the OpenMRN-Lite community.</p>
<h2 id="prerequisites--assumptions"><a class="header" href="#prerequisites--assumptions">Prerequisites &amp; Assumptions</a></h2>
<p>Before diving into the next chapter, make sure you have:</p>
<p><strong>Knowledge</strong>:</p>
<ul>
<li>Basic embedded programming (C/C++)</li>
<li>Microcontroller I/O concepts (GPIO, digital read/write)</li>
<li>Familiarity with breadboards and simple circuits</li>
<li>Producer/consumer model understanding (from using LCC products)</li>
</ul>
<p><strong>Hardware</strong> (needed for Chapter 3):</p>
<ul>
<li>ESP32 development board (ESP32 DevKit v1 or similar)</li>
<li>USB cable for programming</li>
<li>Breadboard and jumper wires</li>
<li>Push button (momentary, normally open)</li>
<li>LED (any color)</li>
<li>220Ω resistor (for LED current limiting)</li>
<li>Computer with WiFi (for network connection)</li>
</ul>
<p><strong>Software</strong> (installation covered in Chapter 3):</p>
<ul>
<li>VS Code or similar editor</li>
<li>PlatformIO extension</li>
<li>JMRI (for monitoring OpenLCB traffic)</li>
</ul>
<p>If you're missing any hardware, most items can be purchased as a kit from electronics suppliers (Adafruit, SparkFun, Amazon, AliExpress) for under $20 USD total.</p>
<h2 id="development-environment-overview"><a class="header" href="#development-environment-overview">Development Environment Overview</a></h2>
<p>We'll be using modern, cross-platform tools:</p>
<p><strong>PlatformIO</strong>: A professional build system and IDE extension that handles:</p>
<ul>
<li>Automatic toolchain installation</li>
<li>Library dependency management</li>
<li>Serial monitoring and debugging</li>
<li>Support for hundreds of boards and frameworks</li>
</ul>
<p><strong>Arduino Framework</strong>: Provides:</p>
<ul>
<li>Familiar <code>setup()</code> and <code>loop()</code> structure</li>
<li>Standard GPIO functions (<code>pinMode</code>, <code>digitalWrite</code>, etc.)</li>
<li>WiFi libraries for ESP32</li>
<li>Large ecosystem of compatible libraries</li>
</ul>
<p><strong>OpenMRNLite Library</strong>: The core OpenLCB implementation:</p>
<ul>
<li>Complete protocol stack (startup, events, datagrams, streams)</li>
<li>SimpleStack API for easy setup</li>
<li>Event producers and consumers</li>
<li>TCP and CAN transport support</li>
<li>Memory-efficient design for microcontrollers</li>
</ul>
<p>Chapter 3 will walk through installation and configuration step-by-step. No prior PlatformIO experience required.</p>
<h2 id="understanding-openmrn-lite"><a class="header" href="#understanding-openmrn-lite">Understanding OpenMRN-Lite</a></h2>
<p>Before we dive into code, you might be wondering: <strong>What exactly is OpenMRN-Lite? Is it a cut-down version? Will I outgrow it?</strong></p>
<p>Chapter 2.5 (&quot;OpenMRN-Lite Architecture &amp; Capabilities&quot;) answers these questions in detail. It explains:</p>
<ul>
<li>Why OpenMRN-Lite is the <em>only</em> OpenMRN version that runs on Arduino (not a limitation, just a fact)</li>
<li>What features it supports (CDI, events, datagrams, CAN, and more)</li>
<li>When you might want to switch toolchains entirely (and when you won't)</li>
</ul>
<p>For now, know this: <strong>OpenMRN-Lite is the right tool for learning OpenLCB on ESP32.</strong> It has everything you need to build real nodes, and understanding how it works sets you up perfectly for more advanced projects later.</p>
<h2 id="monitoring-with-jmri-tcp"><a class="header" href="#monitoring-with-jmri-tcp">Monitoring with JMRI (TCP)</a></h2>
<p>JMRI (Java Model Railroad Interface) is an essential tool for working with OpenLCB:</p>
<p><strong>Why JMRI?</strong></p>
<ul>
<li><strong>Message decoder</strong> - Translates raw hex into readable OpenLCB messages</li>
<li><strong>Network monitor</strong> - See all CID, RID, AMD, event messages in real-time</li>
<li><strong>Testing tool</strong> - Send events to your node and verify responses</li>
<li><strong>Layout integration</strong> - Connect your node to a larger LCC network</li>
</ul>
<p><strong>TCP/GridConnect Protocol</strong>: JMRI connects to your ESP32 node over WiFi using:</p>
<ul>
<li>TCP socket connection (default port 12021)</li>
<li>GridConnect ASCII format: <code>:X&lt;header&gt;N&lt;data&gt;;</code></li>
<li>Human-readable message traces</li>
<li>Standard format used by many OpenLCB tools</li>
</ul>
<p><strong>What You'll See</strong>: When your node starts up, JMRI shows:</p>
<ol>
<li>Four CID frames (checking alias availability)</li>
<li>RID frame (reserving alias)</li>
<li>AMD frame (mapping Node ID to alias)</li>
<li>Initialized message (node is online)</li>
<li>Producer/Consumer Identified messages (node capabilities)</li>
<li>Event reports (button presses, LED changes)</li>
</ol>
<p>Chapter 3 includes detailed JMRI setup and verification steps. You'll see your first OpenLCB messages within minutes of uploading code.</p>
<h2 id="network-architecture-hubs-and-nodes"><a class="header" href="#network-architecture-hubs-and-nodes">Network Architecture: Hubs and Nodes</a></h2>
<p>Now that we've introduced JMRI, it's important to understand the architecture that makes this all work. An OpenLCB network consists of two types of participants working together:</p>
<p><strong>Nodes</strong> are devices that produce and consume events—like your ESP32 with a button and LED. Each node has a unique 6-byte identifier and announces itself when joining the network.</p>
<p><strong>Hubs</strong> are central coordinators that route messages between nodes. In a WiFi/TCP network, the hub is a TCP server listening on port 12021. When JMRI or other tools connect to the hub, they can see all network traffic and send commands to any node.</p>
<p>The clever part: your ESP32 can be <strong>both a node and a hub simultaneously</strong>. It runs the OpenLCB protocol stack (making it a node), and it also runs a TCP Hub service (making it a network coordinator). This is exactly what we'll do in Chapter 3—create a single device that acts as both.</p>
<p>Here's how the architecture works:</p>
<pre><code class="language-mermaid">graph TB
    subgraph ESP32[&quot;ESP32 Device&quot;]
        Node[&quot;OpenLCB Node&lt;br/&gt;(produces/consumes events)&quot;]
        Hub[&quot;TCP Hub&lt;br/&gt;(port 12021)&quot;]
        Node ---|message routing| Hub
    end
    
    JMRI[&quot;JMRI Monitor&lt;br/&gt;(TCP Client)&quot;]
    Node2[&quot;Other ESP32 Node&lt;br/&gt;(optional future)&quot;]
    CAN[&quot;CAN Bus&lt;br/&gt;(optional future)&quot;]
    
    JMRI ---|TCP connection| Hub
    Node2 ---|TCP connection| Hub
    CAN -.-&gt;|CAN transceiver| Hub
    
    style ESP32 fill:#e1f5ff
    style Node fill:#fff9c4
    style Hub fill:#f3e5f5
    style CAN fill:#eeeeee
    style Node2 fill:#eeeeee
</code></pre>
<p><strong>What You See in This Architecture</strong>:</p>
<ul>
<li><strong>ESP32 Node</strong>: Produces events (button presses) and consumes events (LED changes). It announces itself to the network during startup with the CID/RID/AMD sequence.</li>
<li><strong>TCP Hub</strong>: Listens on port 12021, accepts connections from JMRI and other TCP clients, and forwards all OpenLCB messages between connected participants.</li>
<li><strong>JMRI Monitor</strong>: Connects as a TCP client to see all network traffic. Can send test events to your node and observe responses.</li>
<li><strong>Future Expansion</strong>: You can add more ESP32 nodes (all connecting to the same hub), or add CAN hardware to bridge between TCP and CAN participants.</li>
</ul>
<p><strong>Why This Design?</strong> OpenMRNLite makes it easy to add a TCP Hub service to any node. The hub needs just a few lines of code—we'll see this in Chapter 3. This approach is perfect for learning because:</p>
<ol>
<li><strong>No extra hardware</strong> - The hub runs on the same ESP32 as your node</li>
<li><strong>Scalable</strong> - Add more nodes just by connecting them to port 12021</li>
<li><strong>Transport-agnostic</strong> - Whether using TCP, CAN, or both, the message format stays the same</li>
<li><strong>Future-proof</strong> - Later chapters will add CAN hardware and integrate it seamlessly with the existing TCP hub</li>
</ol>
<p>We're starting with <strong>TCP because it requires no special hardware</strong>. In later chapters, we'll add CAN transceivers to support traditional LCC installations—but the hub concept remains identical.</p>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next</a></h2>
<p>Now that you understand the platform choices and tools, Chapter 3 will guide you through:</p>
<ol>
<li><strong>Installing PlatformIO</strong> - Step-by-step setup in VS Code</li>
<li><strong>Installing OpenMRNLite</strong> - Adding the library to your project</li>
<li><strong>Building async_blink_esp32</strong> - Complete walkthrough of the example code</li>
<li><strong>Deploying to ESP32</strong> - Upload and run your first OpenLCB node</li>
<li><strong>Verification with JMRI</strong> - See your node join the network and exchange events over WiFi</li>
<li><strong>Troubleshooting</strong> - Common issues and solutions</li>
</ol>
<p>By the end of Chapter 3, you'll have a working OpenLCB node that you built yourself. You'll understand the code, see the messages, and be ready to create your own custom nodes.</p>
<p>Chapter 4 will then cover adding physical buttons and LEDs to interact with the real world.</p>
<p>Let's get started!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="intro_ab_events.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="openmrn-architecture.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="intro_ab_events.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="openmrn-architecture.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="mermaid.min.js"></script>
                <script type="text/javascript" src="mermaid-init.js"></script>
        
        
    </body>
</html>
